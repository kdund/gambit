diff -rupN pythia8306_original/include/Pythia8/Event.h pythia8306_patched/include/Pythia8/Event.h
--- pythia8306_original/include/Pythia8/Event.h	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/include/Pythia8/Event.h	2023-06-27 02:09:11.924196135 +0200
@@ -480,7 +480,8 @@ public:
 
   // List the particles in an event.
   void list(bool showScaleAndVertex = false,
-    bool showMothersAndDaughters = false, int precision = 3) const;
+    bool showMothersAndDaughters = false, int precision = 3, ostream& os = cout) const;
+  void list(ostream& os, int precision) const { list(false, true, precision, os); }
 
   // Remove last n entries.
   void popBack(int nRemove = 1) { if (nRemove ==1) entry.pop_back();
diff -rupN pythia8306_original/include/Pythia8/GAMBIT_hepmc_writer.h pythia8306_patched/include/Pythia8/GAMBIT_hepmc_writer.h
--- pythia8306_original/include/Pythia8/GAMBIT_hepmc_writer.h	1970-01-01 01:00:00.000000000 +0100
+++ pythia8306_patched/include/Pythia8/GAMBIT_hepmc_writer.h	2023-06-27 02:09:11.924196135 +0200
@@ -0,0 +1,106 @@
+#ifndef Pythia8_GAMBIT_hepmc_writer_H
+#define Pythia8_GAMBIT_hepmc_writer_H
+
+#include "HepMC3/GenEvent.h"
+#include "HepMC3/WriterAscii.h"
+#include "HepMC3/WriterAsciiHepMC2.h"
+#include "HepMC3/Print.h"
+
+#include "Pythia8/Pythia.h"
+#include "Pythia8Plugins/HepMC3.h"
+
+
+namespace Pythia8
+{
+
+  class GAMBIT_hepmc_writer
+  {
+
+  private:
+
+    std::string filename2;
+    std::string filename3;
+
+    bool HepMC2_ON = false;
+    bool HepMC3_ON = false;
+
+    HepMC3::Pythia8ToHepMC3 *pythiaToHepMC;
+    HepMC3::WriterAsciiHepMC2 *file2;
+    HepMC3::WriterAscii *file3;
+
+
+  public:
+
+    // Destructor
+    ~GAMBIT_hepmc_writer()
+    {
+      if(HepMC2_ON)
+      {
+        file2->close();
+        delete file2;
+      }
+
+      if(HepMC3_ON)
+      {
+        file3->close();
+        delete file3;
+      }
+
+      delete pythiaToHepMC;
+    }
+
+    void init(std::string filename_in, bool HepMC2, bool HepMC3)
+    {
+      if (HepMC2)
+      {
+        filename2 = filename_in+"2";
+        file2 = new HepMC3::WriterAsciiHepMC2(filename2.c_str());
+        HepMC2_ON = true;
+      }
+
+      if (HepMC3)
+      {
+        filename3 = filename_in+"3";
+        file3 = new HepMC3::WriterAscii(filename3.c_str());
+        HepMC3_ON = true;
+      }
+
+      pythiaToHepMC = new HepMC3::Pythia8ToHepMC3();
+    }
+
+
+    // Write current event to file in HepMC3 format
+    void write_event_HepMC3(Pythia* pythia)
+    {
+      // Construct new empty HepMC event and fill it.
+      HepMC3::GenEvent hepmc( HepMC3::Units::GEV, HepMC3::Units::MM );
+
+      pythiaToHepMC->fill_next_event(pythia->event, &hepmc, -1, &(pythia->info));
+
+      // Write the HepMC event to file. Done with it.
+      file3->write_event(hepmc);
+    }
+
+    // Write current event to file in HepMC2 format
+    void write_event_HepMC2(Pythia* pythia)
+    {
+      // Construct new empty HepMC event and fill it.
+      HepMC3::GenEvent hepmc( HepMC3::Units::GEV, HepMC3::Units::MM );
+
+      pythiaToHepMC->fill_next_event(pythia->event, &hepmc, -1, &(pythia->info));
+
+      // Write the HepMC event to file. Done with it.
+      file2->write_event(hepmc);
+    }
+
+    // Returns current event in HepMC format
+    void convert_to_HepMC_event(Pythia *pythia, HepMC3::GenEvent &event)
+    {
+      pythiaToHepMC->fill_next_event(pythia->event, &event, -1, &(pythia->info));
+    }
+
+  };
+
+}
+
+#endif // Pythia8_GAMBIT_hepmc_writer_H
diff -rupN pythia8306_original/include/Pythia8/Info.h pythia8306_patched/include/Pythia8/Info.h
--- pythia8306_original/include/Pythia8/Info.h	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/include/Pythia8/Info.h	2023-06-27 02:09:11.924196135 +0200
@@ -281,7 +281,7 @@ public:
   int    iBMPI(int i)         const {return iBMPISave[i];}
 
   // Cross section estimate, optionally process by process.
-  vector<int> codesHard();
+  vector<int> codesHard() const;
   string nameProc(int i = 0)  const {return (i == 0) ? "sum"
     : ( (procNameM.at(i) == "") ? "unknown process" : procNameM.at(i) );}
   long   nTried(int i = 0)    const {return (i == 0) ? nTry : nTryM.at(i);}
diff -rupN pythia8306_original/include/Pythia8/PartonDistributions.h pythia8306_patched/include/Pythia8/PartonDistributions.h
--- pythia8306_original/include/Pythia8/PartonDistributions.h	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/include/Pythia8/PartonDistributions.h	2023-06-27 02:09:11.924196135 +0200
@@ -383,7 +383,7 @@ public:
 
   // Constructor.
   MSTWpdf(int idBeamIn = 2212, int iFitIn = 1,
-    string pdfdataPath = "../share/Pythia8/pdfdata/", Info* infoPtr = 0)
+    string pdfdataPath = "../pdfdata/", Info* infoPtr = 0)
     : PDF(idBeamIn), iFit(), alphaSorder(), alphaSnfmax(), mCharm(), mBottom(),
     alphaSQ0(), alphaSMZ(), distance(), tolerance(), xx(), qq(),
     c() {init( iFitIn,  pdfdataPath, infoPtr);}
@@ -452,7 +452,7 @@ public:
 
   // Constructor.
   CTEQ6pdf(int idBeamIn = 2212, int iFitIn = 1, double rescaleIn = 1.,
-    string pdfdataPath = "../share/Pythia8/pdfdata/", Info* infoPtr = 0)
+    string pdfdataPath = "../pdfdata/", Info* infoPtr = 0)
     : PDF(idBeamIn), doExtraPol(false), iFit(), order(), nQuark(), nfMx(),
     mxVal(), nX(), nT(), nG(), iGridX(), iGridQ(), iGridLX(), iGridLQ(),
     rescale(rescaleIn), lambda(), mQ(), qIni(), qMax(), tv(), xMin(), xv(),
@@ -603,7 +603,7 @@ public:
 
   // Constructor.
  PomH1FitAB(int idBeamIn = 990, int iFit = 1, double rescaleIn = 1.,
-   string pdfdataPath = "../share/Pythia8/pdfdata/", Info* infoPtr = 0)
+   string pdfdataPath = "../pdfdata/", Info* infoPtr = 0)
    : PDF(idBeamIn), doExtraPol(false), nx(), nQ2(), rescale(rescaleIn), xlow(),
     xupp(), dx(), Q2low(), Q2upp(), dQ2(), gluonGrid(), quarkGrid()
     { init( iFit, pdfdataPath, infoPtr); }
@@ -650,7 +650,7 @@ public:
 
   // Constructor.
   PomH1Jets(int idBeamIn = 990, int iFit = 1, double rescaleIn = 1.,
-    string pdfdataPath = "../share/Pythia8/pdfdata/", Info* infoPtr = 0)
+    string pdfdataPath = "../pdfdata/", Info* infoPtr = 0)
     : PDF(idBeamIn), doExtraPol(false), rescale(rescaleIn), xGrid(), Q2Grid(),
     gluonGrid(), singletGrid(), charmGrid()
     {init( iFit, pdfdataPath, infoPtr);}
diff -rupN pythia8306_original/include/Pythia8/ProcessLevel.h pythia8306_patched/include/Pythia8/ProcessLevel.h
--- pythia8306_original/include/Pythia8/ProcessLevel.h	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/include/Pythia8/ProcessLevel.h	2023-06-27 02:09:11.924196135 +0200
@@ -76,6 +76,9 @@ public:
 
   bool nextDecays( Event& process) { return resonanceDecays.next( process);}
 
+  // GAMBIT
+  double sigmaMaxSum;
+
 protected:
 
   virtual void onInitInfoPtr() override {
@@ -102,7 +105,8 @@ private:
   // Vector of containers of internally-generated processes.
   vector<ProcessContainer*> containerPtrs;
   int    iContainer, iLHACont = -1;
-  double sigmaMaxSum;
+  // GAMBIT
+  // double sigmaMaxSum;
 
   // Ditto for optional choice of a second hard process.
   vector<ProcessContainer*> container2Ptrs;
diff -rupN pythia8306_original/include/Pythia8/Pythia.h pythia8306_patched/include/Pythia8/Pythia.h
--- pythia8306_original/include/Pythia8/Pythia.h	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/include/Pythia8/Pythia.h	2023-06-27 02:09:11.924196135 +0200
@@ -73,7 +73,13 @@ public:
   // object instead of XML files (to speed up multiple initialisations).
   Pythia(Settings& settingsIn, ParticleData& particleDataIn,
     bool printBanner = true);
-
+    
+  // GAMBIT patch
+  // This is a bit silly, but needed for compatibility with the interface to Pythia 8.212
+  // If this is removed, a change to the corresponding call in ColliderBit is needed
+  Pythia(ParticleData& particleDataIn, Settings& settingsIn,
+    bool printBanner = true) : Pythia(settingsIn, particleDataIn, printBanner) { }
+  
   // Constructor taking input from streams instead of files.
   Pythia( istream& settingsStrings, istream& particleDataStrings,
     bool printBanner = true);
@@ -266,6 +272,12 @@ public:
   PDFPtr getPDFPtr(int idIn, int sequence = 1, string beam = "A",
     bool resolved = true);
 
+  // GAMBIT patch
+  double getSigmaMaxSum()
+  {
+    return processLevel.sigmaMaxSum;
+  }
+
   // The event record for the parton-level central process.
   Event           process = {};
 
diff -rupN pythia8306_original/include/Pythia8/SusyLesHouches.h pythia8306_patched/include/Pythia8/SusyLesHouches.h
--- pythia8306_original/include/Pythia8/SusyLesHouches.h	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/include/Pythia8/SusyLesHouches.h	2023-06-27 02:09:11.924196135 +0200
@@ -15,6 +15,12 @@
 
 #include "Pythia8/PythiaStdlib.h"
 
+
+// NOTE: Gambit hack to include slhaea support
+// SLHAea (for SLHA input from an SLHAea object instead of a file)
+#include "SLHAea/slhaea.h"
+
+
 namespace Pythia8 {
 
 //==========================================================================
@@ -401,11 +407,12 @@ public:
   //Constructor, with and without filename.
   SusyLesHouches(int verboseIn=1) : verboseSav(verboseIn),
     headerPrinted(false), footerPrinted(false), filePrinted(false),
-    slhaRead(false), lhefRead(false), lhefSlha(false), useDecay(true) {};
+    slhaRead(false), lhefRead(false), lhefSlha(false), useDecay(true),
+    slhaeaCollPtr(NULL) {}; // NOTE: <== slhaeaCollPtr is a Gambit hack
   SusyLesHouches(string filename, int verboseIn=1) : verboseSav(verboseIn),
     headerPrinted(false), footerPrinted(false), filePrinted(false),
-    slhaRead(true), lhefRead(false), lhefSlha(false), useDecay(true)
-    {readFile(filename);};
+    slhaRead(true), lhefRead(false), lhefSlha(false), useDecay(true),
+    slhaeaCollPtr(NULL) {readFile(filename);}; // NOTE: <== slhaeaCollPtr is a Gambit hack
 
   //***************************** SLHA FILE I/O *****************************//
   // Read and write SLHA files
@@ -415,6 +422,9 @@ public:
     bool useDecayIn=true);
   //int writeFile(string filename): write SLHA file on filename
 
+  // NOTE: Gambit hack to include slhaea support
+  void setSLHAea(const SLHAea::Coll* inputSLHAea) { slhaeaCollPtr = inputSLHAea; }
+  
   //Output utilities
   void listHeader();   // print Header
   void listFooter();   // print Footer
@@ -651,6 +661,10 @@ private:
   int verboseSav;
   bool headerPrinted, footerPrinted, filePrinted;
   bool slhaRead, lhefRead, lhefSlha, useDecay;
+  
+  // NOTE: Gambit hack to include slhaea support
+  // SLHAea Collection (for SLHA input from a SLHAea::Coll instead of a file)
+  const SLHAea::Coll* slhaeaCollPtr;
 
 };
 
diff -rupN pythia8306_original/include/Pythia8Plugins/GeneratorInput.h pythia8306_patched/include/Pythia8Plugins/GeneratorInput.h
--- pythia8306_original/include/Pythia8Plugins/GeneratorInput.h	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/include/Pythia8Plugins/GeneratorInput.h	2023-06-27 02:09:11.924196135 +0200
@@ -196,1044 +196,6 @@ private:
 
 };
 
-//==========================================================================
-
-// Main implementation of AlpgenPar class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-//--------------------------------------------------------------------------
-
-// Constants: could be changed here if desired, but normally should not.
-// These are of technical nature, as described for each.
-
-// A zero threshold value for double comparisons.
-const double AlpgenPar::ZEROTHRESHOLD = 1e-10;
-
-//--------------------------------------------------------------------------
-
-// Warn if e/pT imbalance greater than these values
-// Parse an incoming Alpgen parameter file string
-
-inline bool AlpgenPar::parse(const string paramStr) {
-
-  // Read par file in blocks:
-  //   0 - process information
-  //   1 - run parameters
-  //   2 - cross sections
-  int block = 0;
-
-  // Loop over incoming lines
-  stringstream paramStream(paramStr);
-  string line;
-  while (getline(paramStream, line)) {
-
-    // Change to 'run parameters' block
-    if        (line.find("run parameters") != string::npos) {
-      block = 1;
-
-    // End of 'run parameters' block
-    } else if (line.find("end parameters") != string::npos) {
-      block = 2;
-
-    // Do not extract anything from block 0 so far
-    } else if (block == 0) {
-
-    // Block 1 or 2: extract parameters
-    } else {
-      extractRunParam(line);
-
-    }
-  } // while (getline(paramStream, line))
-
-  return true;
-}
-
-//--------------------------------------------------------------------------
-
-// Parse an incoming parameter line
-
-inline void AlpgenPar::extractRunParam(string line) {
-
-  // Extract information to the right of the final '!' character
-  size_t idx = line.rfind("!");
-  if (idx == string::npos) return;
-  string paramName = trim(line.substr(idx + 1));
-  string paramVal  = trim(line.substr(0, idx));
-  istringstream iss(paramVal);
-
-  // Special case: 'hard process code' - single integer input
-  double val;
-  if (paramName == "hard process code") {
-    iss >> val;
-    warnParamOverwrite("hpc", val);
-    params["hpc"] = val;
-
-  // Special case: 'Crosssection +- error (pb)' - two double values
-  } else if (paramName.find("Crosssection") == 0) {
-    double xerrup;
-    iss >> val >> xerrup;
-    warnParamOverwrite("xsecup", val);
-    warnParamOverwrite("xerrup", val);
-    params["xsecup"] = val;
-    params["xerrup"] = xerrup;
-
-  // Special case: 'unwtd events, lum (pb-1)' - integer and double values
-  } else if (paramName.find("unwtd events") == 0) {
-    int nevent;
-    iss >> nevent >> val;
-    warnParamOverwrite("nevent", val);
-    warnParamOverwrite("lum", val);
-    params["nevent"] = nevent;
-    params["lum"]    = val;
-
-  // Special case: 'mc,mb,...' - split on ',' for name and ' ' for values
-  } else if (paramName.find(",") != string::npos) {
-
-    // Simple tokeniser
-    string        paramNameNow;
-    istringstream issName(paramName);
-    while (getline(issName, paramNameNow, ',')) {
-      iss >> val;
-      warnParamOverwrite(paramNameNow, val);
-      params[paramNameNow] = val;
-    }
-
-  // Default case: assume integer and double on the left
-  } else {
-    int paramIdx;
-    iss >> paramIdx >> val;
-    warnParamOverwrite(paramName, val);
-    params[paramName] = val;
-  }
-}
-
-//--------------------------------------------------------------------------
-
-// Print parameters read from the '.par' file
-
-inline void AlpgenPar::printParams() {
-
-  // Loop over all stored parameters and print
-  cout << fixed << setprecision(3) << endl
-       << " *-------  Alpgen parameters  -------*" << endl;
-  for (map < string, double >::iterator it = params.begin();
-       it != params.end(); ++it)
-    cout << " |  " << left << setw(13) << it->first
-         << "  |  " << right << setw(13) << it->second
-         << "  |" << endl;
-  cout << " *-----------------------------------*" << endl;
-}
-
-//--------------------------------------------------------------------------
-
-// Warn if a parameter is going to be overwriten
-
-inline void AlpgenPar::warnParamOverwrite(const string &paramIn, double val) {
-
-  // Check if present and if new value is different
-  if (haveParam(paramIn) &&
-      abs(getParam(paramIn) - val) > ZEROTHRESHOLD) {
-    cout << "Warning in LHAupAlpgen::warnParamOverwrite:"
-         << " overwriting existing parameter" << paramIn << endl;
-  }
-}
-
-//--------------------------------------------------------------------------
-
-// Simple string trimmer
-
-inline string AlpgenPar::trim(string s) {
-
-  // Remove whitespace in incoming string
-  size_t i;
-  if ((i = s.find_last_not_of(" \t\r\n")) != string::npos)
-    s = s.substr(0, i + 1);
-  if ((i = s.find_first_not_of(" \t\r\n")) != string::npos)
-    s = s.substr(i);
-  return s;
-}
-
-//==========================================================================
-
-// Main implementation of LHAupAlpgen class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-// ----------------------------------------------------------------------
-
-// Constants: could be changed here if desired, but normally should not.
-// These are of technical nature, as described for each.
-
-// Debug flag to print all particles in each event.
-const bool LHAupAlpgen::LHADEBUG        = false;
-
-// Debug flag to print particles when an e/p imbalance is found.
-const bool LHAupAlpgen::LHADEBUGRESCALE = false;
-
-// A zero threshold value for double comparisons.
-const double LHAupAlpgen::ZEROTHRESHOLD   = 1e-10;
-
-// Warn if e/pT imbalance greater than these values
-const double LHAupAlpgen::EWARNTHRESHOLD  = 3e-3;
-const double LHAupAlpgen::PTWARNTHRESHOLD = 1e-3;
-
-// If incoming e/pZ is 0, it is reset to this value
-const double LHAupAlpgen::INCOMINGMIN     = 1e-3;
-
-// ----------------------------------------------------------------------
-
-// Constructor. Opens parameter file and parses then opens event file.
-
-LHAupAlpgen::LHAupAlpgen(const char* baseFNin)
-  : baseFN(baseFNin), alpgenPar(), isUnw(NULL) {
-
-  // Read in '_unw.par' file to get parameters
-  ifstream  ifsPar;
-  istream*  isPar = NULL;
-
-  // Try gzip file first then normal file afterwards
-#ifdef GZIP
-  parFN = baseFN + "_unw.par.gz";
-  isPar = openFile(parFN.c_str(), ifsPar);
-  if (!ifsPar.is_open()) closeFile(isPar, ifsPar);
-#endif
-  if (isPar == NULL) {
-    parFN = baseFN + "_unw.par";
-    isPar = openFile(parFN.c_str(), ifsPar);
-    if (!ifsPar.is_open()) {
-      cout << "Error in LHAupAlpgen::LHAupAlpgen: "
-           << "cannot open parameter file " << parFN << endl;
-      closeFile(isPar, ifsPar);
-      return;
-    }
-  }
-
-  // Read entire contents into string and close file
-  string paramStr((std::istreambuf_iterator<char>(isPar->rdbuf())),
-                   std::istreambuf_iterator<char>());
-
-  // Make sure we reached EOF and not other error
-  if (ifsPar.bad()) {
-    cout << "Error in LHAupAlpgen::LHAupAlpgen: "
-         << "cannot read parameter file " << parFN << endl;
-    return;
-  }
-  closeFile(isPar, ifsPar);
-
-  // Parse file and set LHEF header
-  alpgenPar.parse(paramStr);
-  setInfoHeader("AlpgenPar", paramStr);
-
-  // Open '.unw' events file (with possible gzip support)
-#ifdef GZIP
-  unwFN = baseFN + ".unw.gz";
-  isUnw = openFile(unwFN.c_str(), ifsUnw);
-  if (!ifsUnw.is_open()) closeFile(isUnw, ifsUnw);
-#endif
-  if (isUnw == NULL) {
-    unwFN = baseFN + ".unw";
-    isUnw = openFile(unwFN.c_str(), ifsUnw);
-    if (!ifsUnw.is_open()) {
-      cout << "Error in LHAupAlpgen::LHAupAlpgen: "
-           << "cannot open event file " << unwFN << endl;
-      closeFile(isUnw, ifsUnw);
-    }
-  }
-}
-
-// ----------------------------------------------------------------------
-
-// setInit is a virtual method that must be finalised here.
-// Sets up beams, strategy and processes.
-
-inline bool LHAupAlpgen::setInit() {
-
-  // Check that all required parameters are present
-  if (!alpgenPar.haveParam("ih2") || !alpgenPar.haveParam("ebeam")  ||
-      !alpgenPar.haveParam("hpc") || !alpgenPar.haveParam("xsecup") ||
-      !alpgenPar.haveParam("xerrup")) {
-    cout << "Error in LHAupAlpgen::setInit: "
-         << "missing input parameters" << endl;
-    return false;
-  }
-
-  // Beam IDs
-  int ih2 = alpgenPar.getParamAsInt("ih2");
-  int idbmupA = 2212;
-  int idbmupB = (ih2 == 1) ? 2212 : -2212;
-
-  // Beam energies
-  double ebeam = alpgenPar.getParam("ebeam");
-  ebmupA = ebeam;
-  ebmupB = ebmupA;
-
-  // PDF group and set (at the moment not set)
-  int pdfgupA = 0, pdfsupA = 0;
-  int pdfgupB = 0, pdfsupB = 0;
-
-  // Strategy is for unweighted events and xmaxup not important
-  int    idwtup = 3;
-  double xmaxup = 0.;
-
-  // Get hard process code
-  lprup = alpgenPar.getParamAsInt("hpc");
-
-  // Check for unsupported processes
-  if (lprup == 7 || lprup == 8 || lprup == 13) {
-    cout << "Error in LHAupAlpgen::setInit: "
-         << "process not implemented" << endl;
-    return false;
-  }
-
-  // Depending on the process code, get heavy flavour information:
-  //    6 = QQbar           + jets
-  //    7 = QQbar + Q'Qbar' + jets
-  //    8 = QQbar + Higgs   + jets
-  //   16 = QQbar + gamma   + jets
-  if (lprup == 6 || lprup == 7 || lprup == 8 || lprup == 16) {
-    if (!alpgenPar.haveParam("ihvy")) {
-      cout << "Error in LHAupAlpgen::setInit: "
-           << "heavy flavour information not present" << endl;
-      return false;
-    }
-    ihvy1 = alpgenPar.getParamAsInt("ihvy");
-
-  } else ihvy1 = -1;
-  if (lprup == 7) {
-    if (!alpgenPar.haveParam("ihvy2")) {
-      cout << "Error in LHAupAlpgen::setInit: "
-           << "heavy flavour information not present" << endl;
-      return false;
-    }
-    ihvy2 = alpgenPar.getParamAsInt("ihvy2");
-  } else ihvy2 = -1;
-  // For single top (process 13), get b mass to set incoming
-  mb = -1.;
-  if (lprup == 13) {
-    if (!alpgenPar.haveParam("mb")) {
-      cout << "Error in LHAupAlpgen::setInit: "
-           << "heavy flavour information not present" << endl;
-      return false;
-    }
-    mb = alpgenPar.getParam("mb");
-  }
-
-  // Set the beams
-  setBeamA(idbmupA, ebmupA, pdfgupA, pdfsupA);
-  setBeamB(idbmupB, ebmupB, pdfgupB, pdfsupB);
-  setStrategy(idwtup);
-
-  // Add the process
-  double xsecup = alpgenPar.getParam("xsecup");
-  double xerrup = alpgenPar.getParam("xerrup");
-  addProcess(lprup, xsecup, xerrup, xmaxup);
-  xSecSumSave = xsecup;
-  xErrSumSave = xerrup;
-
-  // All okay
-  return true;
-}
-
-// ----------------------------------------------------------------------
-
-// setEvent is a virtual method that must be finalised here.
-// Read in an event from the 'unw' file and setup.
-
-inline bool LHAupAlpgen::setEvent(int) {
-
-  // Read in the first line of the event
-  int    nEvent, iProc, nParton;
-  double Swgt, Sq;
-  string line;
-  if (!getline(*isUnw, line)) {
-    // Read was bad
-    if (ifsUnw.bad()) {
-      cout << "Error in LHAupAlpgen::setEvent: "
-           << "could not read events from file" << endl;
-      return false;
-    }
-    // End of file reached
-    cout << "Error in LHAupAlpgen::setEvent: "
-         << "end of file reached" << endl;
-    return false;
-  }
-  istringstream iss1(line);
-  iss1 >> nEvent >> iProc >> nParton >> Swgt >> Sq;
-
-  // Set the process details (ignore alphaQED and alphaQCD parameters)
-  double wgtT = Swgt, scaleT = Sq;
-  setProcess(lprup, wgtT, scaleT);
-
-  // Incoming flavour and x information for later
-  int    id1T, id2T;
-  double x1T, x2T;
-  // Temporary storage for read in parton information
-  int    idT, statusT, mother1T, mother2T, col1T, col2T;
-  double pxT, pyT, pzT, eT, mT;
-  // Leave tau and spin as default values
-  double tauT = 0., spinT = 9.;
-
-  // Store particles locally at first so that resonances can be added
-  myParticles.clear();
-
-  // Now read in partons
-  for (int i = 0; i < nParton; i++) {
-    // Get the next line
-    if (!getline(*isUnw, line)) {
-      cout << "Error in LHAupAlpgen::setEvent: "
-           << "could not read events from file" << endl;
-      return false;
-    }
-    istringstream iss2(line);
-
-    // Incoming (flavour, colour, anticolour, pz)
-    if (i < 2) {
-      // Note that mothers will be set automatically by Pythia, and LHA
-      // status -1 is for an incoming parton
-      iss2 >> idT >> col1T >> col2T >> pzT;
-      statusT  = -1;
-      mother1T = mother2T = 0;
-      pxT = pyT = mT = 0.;
-      eT  = abs(pzT);
-
-      // Adjust when zero pz/e
-      if (pzT == 0.) {
-        pzT = (i == 0) ? INCOMINGMIN : -INCOMINGMIN;
-        eT  = INCOMINGMIN;
-      }
-
-    // Outgoing (flavour, colour, anticolour, px, py, pz, mass)
-    } else {
-      // Note that mothers 1 and 2 corresport to the incoming partons,
-      // as set above, and LHA status +1 is for outgoing final state
-      iss2 >> idT >> col1T >> col2T >> pxT >> pyT >> pzT >> mT;
-      statusT  = 1;
-      mother1T = 1;
-      mother2T = 2;
-      eT = sqrt(max(0., pxT*pxT + pyT*pyT + pzT*pzT + mT*mT));
-    }
-
-    // Add particle
-    myParticles.push_back(LHAParticle(
-        idT, statusT, mother1T, mother2T, col1T, col2T,
-        pxT, pyT, pzT, eT, mT, tauT, spinT,-1.));
-  }
-
-  // Add resonances if required
-  if (!addResonances()) return false;
-
-  // Rescale momenta if required (must be done after full event
-  // reconstruction in addResonances)
-  if (!rescaleMomenta()) return false;
-
-  // Pass particles on to Pythia
-  for (size_t i = 0; i < myParticles.size(); i++)
-    addParticle(myParticles[i]);
-
-  // Set incoming flavour/x information and done
-  id1T = myParticles[0].idPart;
-  x1T  = myParticles[0].ePart / ebmupA;
-  id2T = myParticles[1].idPart;
-  x2T  = myParticles[1].ePart / ebmupA;
-  setIdX(id1T, id2T, x1T, x2T);
-  setPdf(id1T, id2T, x1T, x2T, 0., 0., 0., false);
-  return true;
-}
-
-// ----------------------------------------------------------------------
-
-// Print list of particles; mainly intended for debugging
-
-inline void LHAupAlpgen::printParticles() {
-
-  cout << endl << "---- LHAupAlpgen particle listing begin ----" << endl;
-  cout << scientific << setprecision(6);
-  for (int i = 0; i < int(myParticles.size()); i++) {
-    cout << setw(5)  << i
-         << setw(5)  << myParticles[i].idPart
-         << setw(5)  << myParticles[i].statusPart
-         << setw(15) << myParticles[i].pxPart
-         << setw(15) << myParticles[i].pyPart
-         << setw(15) << myParticles[i].pzPart
-         << setw(15) << myParticles[i].ePart
-         << setw(15) << myParticles[i].mPart
-         << setw(5)  << myParticles[i].mother1Part - 1
-         << setw(5)  << myParticles[i].mother2Part - 1
-         << setw(5)  << myParticles[i].col1Part
-         << setw(5)  << myParticles[i].col2Part
-         << endl;
-  }
-  cout << "----  LHAupAlpgen particle listing end  ----" << endl;
-}
-
-// ----------------------------------------------------------------------
-
-// Routine to add resonances to an incoming event based on the
-// hard process code (now stored in lprup).
-
-inline bool LHAupAlpgen::addResonances() {
-
-  // Temporary storage for resonance information
-  int    idT, statusT, mother1T, mother2T, col1T, col2T;
-  double pxT, pyT, pzT, eT, mT;
-  // Leave tau and spin as default values
-  double tauT = 0., spinT = 9.;
-
-  // Alpgen process dependent parts. Processes:
-  //    1 = W        + QQbar         + jets
-  //    2 = Z/gamma* + QQbar         + jets
-  //    3 = W                        + jets
-  //    4 = Z/gamma*                 + jets
-  //   10 = W        + c             + jets
-  //   14 = W        + gamma         + jets
-  //   15 = W        + QQbar + gamma + jets
-  // When QQbar = ttbar, tops are not decayed in these processes.
-  // Explicitly reconstruct W/Z resonances; assumption is that the
-  // decay products are the last two particles.
-  if (lprup <= 4 || lprup == 10 || lprup == 14 || lprup == 15) {
-    // Decay products are the last two entries
-    int i1 = myParticles.size() - 1, i2 = i1 - 1;
-
-    // Follow 'alplib/alpsho.f' procedure to get ID
-    if (myParticles[i1].idPart + myParticles[i2].idPart == 0)
-      idT = 0;
-    else
-      idT = - (myParticles[i1].idPart % 2) - (myParticles[i2].idPart % 2);
-    idT = (idT > 0) ? 24 : (idT < 0) ? -24 : 23;
-
-    // Check that we get the expected resonance type; Z/gamma*
-    if (lprup == 2 || lprup == 4) {
-      if (idT != 23) {
-        cout << "Error in "
-             << "LHAupAlpgen::addResonances: wrong resonance type in event"
-             << endl;
-        return false;
-      }
-
-    // W's
-    } else {
-      if (abs(idT) != 24) {
-        cout << "Error in "
-             << "LHAupAlpgen::addResonances: wrong resonance type in event"
-             << endl;
-        return false;
-      }
-    }
-
-    // Remaining input
-    statusT  = 2;
-    mother1T = 1;
-    mother2T = 2;
-    col1T = col2T = 0;
-    pxT = myParticles[i1].pxPart + myParticles[i2].pxPart;
-    pyT = myParticles[i1].pyPart + myParticles[i2].pyPart;
-    pzT = myParticles[i1].pzPart + myParticles[i2].pzPart;
-    eT  = myParticles[i1].ePart  + myParticles[i2].ePart;
-    mT  = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
-    myParticles.push_back(LHAParticle(
-        idT, statusT, mother1T, mother2T, col1T, col2T,
-        pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
-
-    // Update decay product mothers (note array size as if from 1)
-    myParticles[i1].mother1Part = myParticles[i2].mother1Part =
-        myParticles.size();
-    myParticles[i1].mother2Part = myParticles[i2].mother2Part = 0;
-
-  // Processes:
-  //    5 = nW + mZ + j gamma + lH + jets
-  //    6 = QQbar         + jets    (QQbar = ttbar)
-  //    8 = QQbar + Higgs + jets    (QQbar = ttbar)
-  //   13 = top   + q               (topprc = 1)
-  //   13 = top   + b               (topprc = 2)
-  //   13 = top   + W     + jets    (topprc = 3)
-  //   13 = top   + W     + b       (topprc = 4)
-  //   16 = QQbar + gamma + jets    (QQbar = ttbar)
-  //
-  // When tops are present, they are decayed to Wb (both the W and b
-  // are not given), with this W also decaying (decay products given).
-  // The top is marked intermediate, the (intermediate) W is
-  // reconstructed from its decay products, and the decay product mothers
-  // updated. The final-state b is reconstructed from (top - W).
-  //
-  // W/Z resonances are given, as well as their decay products. The
-  // W/Z is marked intermediate, and the decay product mothers updated.
-  //
-  // It is always assumed that decay products are at the end.
-  // For processes 5 and 13, it is also assumed that the decay products
-  // are in the same order as the resonances.
-  // For processes 6, 8 and 16, the possibility of the decay products
-  // being out-of-order is also taken into account.
-  } else if ( ((lprup == 6 || lprup == 8 || lprup == 16) && ihvy1 == 6) ||
-              lprup == 5 || lprup == 13) {
-
-    // Go backwards through the particles looking for W/Z/top
-    int idx = myParticles.size() - 1;
-    for (int i = myParticles.size() - 1; i > -1; i--) {
-
-      // W or Z
-      if (myParticles[i].idPart == 23 ||
-          abs(myParticles[i].idPart) == 24) {
-
-        // Check that decay products and resonance match up
-        int flav;
-        if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
-          flav = 0;
-        else
-          flav = - (myParticles[idx].idPart % 2)
-                 - (myParticles[idx - 1].idPart % 2);
-        flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
-        if (flav != myParticles[i].idPart) {
-          if (infoPtr)
-            infoPtr->errorMsg("Error in LHAupAlpgen::addResonance: "
-                "resonance does not match decay products");
-          return false;
-        }
-
-        // Update status/mothers
-        myParticles[i].statusPart      = 2;
-        myParticles[idx  ].mother1Part = i + 1;
-        myParticles[idx--].mother2Part = 0;
-        myParticles[idx  ].mother1Part = i + 1;
-        myParticles[idx--].mother2Part = 0;
-
-      // Top
-      } else if (abs(myParticles[i].idPart) == 6) {
-
-        // Check that decay products and resonance match up
-        int flav;
-        if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
-          flav = 0;
-        else
-          flav = - (myParticles[idx].idPart % 2)
-                 - (myParticles[idx - 1].idPart % 2);
-        flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
-
-        bool outOfOrder = false, wrongFlavour = false;;
-        if ( abs(flav) != 24 ||
-             (flav ==  24 && myParticles[i].idPart !=  6) ||
-             (flav == -24 && myParticles[i].idPart != -6) ) {
-
-          // Processes 5 and 13, order should always be correct
-          if (lprup == 5 || lprup == 13) {
-            wrongFlavour = true;
-
-          // Processes 6, 8 and 16, can have out of order decay products
-          } else {
-
-            // Go back two decay products and retry
-            idx -= 2;
-            if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
-              flav = 0;
-            else
-              flav = - (myParticles[idx].idPart % 2)
-                     - (myParticles[idx - 1].idPart % 2);
-            flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
-
-            // If still the wrong flavour then error
-            if ( abs(flav) != 24 ||
-                 (flav ==  24 && myParticles[i].idPart !=  6) ||
-                 (flav == -24 && myParticles[i].idPart != -6) )
-              wrongFlavour = true;
-            else outOfOrder = true;
-          }
-
-          // Error if wrong flavour
-          if (wrongFlavour) {
-            if (infoPtr)
-              infoPtr->errorMsg("Error in LHAupAlpgen::addResonance: "
-                  "resonance does not match decay products");
-            return false;
-          }
-        }
-
-        // Mark t/tbar as now intermediate
-        myParticles[i].statusPart = 2;
-
-        // New intermediate W+/W-
-        idT      = flav;
-        statusT  = 2;
-        mother1T = i + 1;
-        mother2T = 0;
-        col1T = col2T = 0;
-        pxT = myParticles[idx].pxPart + myParticles[idx - 1].pxPart;
-        pyT = myParticles[idx].pyPart + myParticles[idx - 1].pyPart;
-        pzT = myParticles[idx].pzPart + myParticles[idx - 1].pzPart;
-        eT  = myParticles[idx].ePart  + myParticles[idx - 1].ePart;
-        mT  = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
-        myParticles.push_back(LHAParticle(
-            idT, statusT, mother1T, mother2T, col1T, col2T,
-            pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
-
-        // Update the decay product mothers
-        myParticles[idx  ].mother1Part = myParticles.size();
-        myParticles[idx--].mother2Part = 0;
-        myParticles[idx  ].mother1Part = myParticles.size();
-        myParticles[idx--].mother2Part = 0;
-
-        // New final-state b/bbar
-        idT     = (flav == 24) ? 5 : -5;
-        statusT = 1;
-        // Colour from top
-        col1T   = myParticles[i].col1Part;
-        col2T   = myParticles[i].col2Part;
-        // Momentum from (t/tbar - W+/W-)
-        pxT     = myParticles[i].pxPart - myParticles.back().pxPart;
-        pyT     = myParticles[i].pyPart - myParticles.back().pyPart;
-        pzT     = myParticles[i].pzPart - myParticles.back().pzPart;
-        eT      = myParticles[i].ePart  - myParticles.back().ePart;
-        mT      = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
-        myParticles.push_back(LHAParticle(
-            idT, statusT, mother1T, mother2T, col1T, col2T,
-            pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
-
-        // If decay products were out of order, reset idx to point
-        // at correct decay products
-        if (outOfOrder) idx += 4;
-
-      } // if (abs(myParticles[i].idPart) == 6)
-    } // for (i)
-
-
-  // Processes:
-  //    7 = QQbar + Q'Qbar' + jets (tops are not decayed)
-  //    9 =                   jets
-  //   11 = gamma           + jets
-  //   12 = Higgs           + jets
-  } else if (lprup == 7 || lprup == 9 || lprup == 11 || lprup == 12) {
-    // Nothing to do for these processes
-  }
-
-  // For single top, set incoming b mass if necessary
-  if (lprup == 13) for (int i = 0; i < 2; i++)
-    if (abs(myParticles[i].idPart) == 5) {
-      myParticles[i].mPart = mb;
-      myParticles[i].ePart = sqrt(pow2(myParticles[i].pzPart) + pow2(mb));
-    }
-
-  // Debug output and done.
-  if (LHADEBUG) printParticles();
-  return true;
-
-}
-
-// ----------------------------------------------------------------------
-
-// Routine to rescale momenta to remove any imbalances. The routine
-// assumes that any imbalances are due to decimal output/rounding
-// effects, and are therefore small.
-//
-// First any px/py imbalances are fixed by adjusting all outgoing
-// particles px/py and also updating their energy so mass is fixed.
-// Because incoming pT is zero, changes should be limited to ~0.001.
-//
-// Second, any pz/e imbalances are fixed by scaling the incoming beams
-// (again, no changes to masses required). Because incoming pz/e is not
-// zero, effects can be slightly larger ~0.002/0.003.
-
-inline bool LHAupAlpgen::rescaleMomenta() {
-
-  // Total momenta in/out
-  int  nOut = 0;
-  Vec4 pIn, pOut;
-  for (int i = 0; i < int(myParticles.size()); i++) {
-    Vec4 pNow = Vec4(myParticles[i].pxPart, myParticles[i].pyPart,
-                     myParticles[i].pzPart, myParticles[i].ePart);
-    if (i < 2) pIn += pNow;
-    else if (myParticles[i].statusPart == 1) {
-      nOut++;
-      pOut += pNow;
-    }
-  }
-
-  // pT out to match pT in. Split any imbalances over all outgoing
-  // particles, and scale energies also to keep m^2 fixed.
-  if (abs(pOut.pT() - pIn.pT()) > ZEROTHRESHOLD) {
-    // Differences in px/py
-    double pxDiff = (pOut.px() - pIn.px()) / nOut,
-           pyDiff = (pOut.py() - pIn.py()) / nOut;
-
-    // Warn if resulting changes above warning threshold
-    if (pxDiff > PTWARNTHRESHOLD || pyDiff > PTWARNTHRESHOLD) {
-      cout << "Warning in LHAupAlpgen::setEvent: "
-           << "large pT imbalance in incoming event" << endl;
-
-      // Debug printout
-      if (LHADEBUGRESCALE) {
-        printParticles();
-        cout << "pxDiff = " << pxDiff << ", pyDiff = " << pyDiff << endl;
-      }
-    }
-
-    // Adjust all final-state outgoing
-    pOut.reset();
-    for (int i = 2; i < int(myParticles.size()); i++) {
-      if (myParticles[i].statusPart != 1) continue;
-      myParticles[i].pxPart -= pxDiff;
-      myParticles[i].pyPart -= pyDiff;
-      myParticles[i].ePart   = sqrt(max(0., pow2(myParticles[i].pxPart) +
-          pow2(myParticles[i].pyPart) + pow2(myParticles[i].pzPart) +
-          pow2(myParticles[i].mPart)));
-      pOut += Vec4(myParticles[i].pxPart, myParticles[i].pyPart,
-                   myParticles[i].pzPart, myParticles[i].ePart);
-    }
-  }
-
-  // Differences in E/pZ and scaling factors
-  double de = (pOut.e()  - pIn.e());
-  double dp = (pOut.pz() - pIn.pz());
-  double a  = 1 + (de + dp) / 2. / myParticles[0].ePart;
-  double b  = 1 + (de - dp) / 2. / myParticles[1].ePart;
-
-  // Warn if resulting energy changes above warning threshold.
-  // Change in pz less than or equal to change in energy (incoming b
-  // quark can have mass at this stage for process 13). Note that for
-  // very small incoming momenta, the relative adjustment may be large,
-  // but still small in absolute terms.
-  if (abs(a - 1.) * myParticles[0].ePart > EWARNTHRESHOLD ||
-      abs(b - 1.) * myParticles[1].ePart > EWARNTHRESHOLD) {
-    cout << "Warning in LHAupAlpgen::setEvent: "
-         << "large rescaling factor" << endl;
-
-    // Debug printout
-    if (LHADEBUGRESCALE) {
-      printParticles();
-      cout << "de = " << de << ", dp = " << dp
-           << ", a = " << a << ", b = " << b << endl
-           << "Absolute energy change for incoming 0 = "
-           << abs(a - 1.) * myParticles[0].ePart << endl
-           << "Absolute energy change for incoming 1 = "
-           << abs(b - 1.) * myParticles[1].ePart << endl;
-    }
-  }
-  myParticles[0].ePart  *= a;
-  myParticles[0].pzPart *= a;
-  myParticles[1].ePart  *= b;
-  myParticles[1].pzPart *= b;
-
-  // Recalculate resonance four vectors
-  for (int i = 0; i < int(myParticles.size()); i++) {
-    if (myParticles[i].statusPart != 2) continue;
-
-    // Only mothers stored in LHA, so go through all
-    Vec4 resVec;
-    for (int j = 0; j < int(myParticles.size()); j++) {
-      if (myParticles[j].mother1Part - 1 != i) continue;
-      resVec += Vec4(myParticles[j].pxPart, myParticles[j].pyPart,
-                     myParticles[j].pzPart, myParticles[j].ePart);
-    }
-
-    myParticles[i].pxPart = resVec.px();
-    myParticles[i].pyPart = resVec.py();
-    myParticles[i].pzPart = resVec.pz();
-    myParticles[i].ePart  = resVec.e();
-  }
-
-  return true;
-}
-
-//==========================================================================
-
-// Main implementation of AlpgenHooks class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-// ----------------------------------------------------------------------
-
-// Constructor: provides the 'Alpgen:file' option by directly
-//              changing the Pythia 'Beams' settings
-
-AlpgenHooks::AlpgenHooks(Pythia &pythia) {
-
-  // If LHAupAlpgen needed, construct and pass to Pythia
-  string agFile = pythia.settings.word("Alpgen:file");
-  if (agFile != "void") {
-    LHAagPtr = make_shared<LHAupAlpgen>(agFile.c_str());
-    pythia.settings.mode("Beams:frameType", 5);
-    pythia.setLHAupPtr(LHAagPtr);
-  }
-}
-
-// ----------------------------------------------------------------------
-
-// Initialisation routine which is called by pythia.init().
-// This happens after the local pointers have been assigned and after
-// Pythia has processed the Beam information (and therefore LHEF header
-// information has been read in), but before any other internal
-// initialisation. Provides the remaining 'Alpgen:*' options.
-
-inline bool AlpgenHooks::initAfterBeams() {
-
-  // Read in ALPGEN specific configuration variables
-  bool setLightMasses = settingsPtr->flag("Alpgen:setLightMasses");
-  bool setHeavyMasses = settingsPtr->flag("Alpgen:setHeavyMasses");
-  bool setNjet   = settingsPtr->flag("Alpgen:setNjet");
-  bool setMLM    = settingsPtr->flag("Alpgen:setMLM");
-
-  // If ALPGEN parameters are present, then parse in AlpgenPar object
-  AlpgenPar par;
-  string parStr = infoPtr->header("AlpgenPar");
-  if (!parStr.empty()) {
-    par.parse(parStr);
-    par.printParams();
-  }
-
-  // Set masses if requested
-  if (setLightMasses) {
-    if (par.haveParam("mc")) particleDataPtr->m0(4,  par.getParam("mc"));
-    if (par.haveParam("mb")) particleDataPtr->m0(5,  par.getParam("mb"));
-  }
-  if (setHeavyMasses) {
-    if (par.haveParam("mt")) particleDataPtr->m0(6,  par.getParam("mt"));
-    if (par.haveParam("mz")) particleDataPtr->m0(23, par.getParam("mz"));
-    if (par.haveParam("mw")) particleDataPtr->m0(24, par.getParam("mw"));
-    if (par.haveParam("mh")) particleDataPtr->m0(25, par.getParam("mh"));
-  }
-
-  // Set MLM:nJets if requested
-  if (setNjet) {
-    if (par.haveParam("njets"))
-      settingsPtr->mode("JetMatching:nJet", par.getParamAsInt("njets"));
-    else
-      cout << "Warning in AlpgenHooks:init: "
-           << "no ALPGEN nJet parameter found" << endl;
-  }
-
-  // Set MLM merging parameters if requested
-  if (setMLM) {
-    if (par.haveParam("ptjmin") && par.haveParam("drjmin") &&
-        par.haveParam("etajmax")) {
-      double ptjmin = par.getParam("ptjmin");
-      ptjmin = max(ptjmin + 5., 1.2 * ptjmin);
-      settingsPtr->parm("JetMatching:eTjetMin",   ptjmin);
-      settingsPtr->parm("JetMatching:coneRadius", par.getParam("drjmin"));
-      settingsPtr->parm("JetMatching:etaJetMax",  par.getParam("etajmax"));
-
-    // Warn if setMLM requested, but parameters not present
-    } else {
-      cout << "Warning in AlpgenHooks:init: "
-           << "no ALPGEN merging parameters found" << endl;
-    }
-  }
-
-  // Initialisation complete.
-  return true;
-}
-
-//==========================================================================
-
-// Main implementation of MadgraphPar class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-//--------------------------------------------------------------------------
-
-// Constants: could be changed here if desired, but normally should not.
-// These are of technical nature, as described for each.
-
-// A zero threshold value for double comparisons.
-const double MadgraphPar::ZEROTHRESHOLD = 1e-10;
-
-//--------------------------------------------------------------------------
-
-// Parse an incoming Madgraph parameter file string
-
-inline bool MadgraphPar::parse(const string paramStr) {
-
-  // Loop over incoming lines
-  stringstream paramStream(paramStr);
-  string line;
-  while ( getline(paramStream, line) ) extractRunParam(line);
-  return true;
-
-}
-
-//--------------------------------------------------------------------------
-
-// Parse an incoming parameter line
-
-inline void MadgraphPar::extractRunParam(string line) {
-
-  // Extract information to the right of the final '!' character
-  size_t idz = line.find("#");
-  if ( !(idz == string::npos) ) return;
-  size_t idx = line.find("=");
-  size_t idy = line.find("!");
-  if (idy == string::npos) idy = line.size();
-  if (idx == string::npos) return;
-  string paramName = trim( line.substr( idx + 1, idy - idx - 1) );
-  string paramVal  = trim( line.substr( 0, idx) );
-  replace( paramVal.begin(), paramVal.end(), 'd', 'e');
-
-  // Simple tokeniser
-  istringstream iss(paramVal);
-  double val;
-  if (paramName.find(",") != string::npos) {
-    string        paramNameNow;
-    istringstream issName( paramName);
-    while ( getline(issName, paramNameNow, ',') ) {
-      iss >> val;
-      warnParamOverwrite( paramNameNow, val);
-      params[paramNameNow] = val;
-    }
-
-  // Default case: assume integer and double on the left
-  } else {
-    iss >> val;
-    warnParamOverwrite( paramName, val);
-    params[paramName] = val;
-  }
-}
-
-//--------------------------------------------------------------------------
-
-// Print parameters read from the '.par' file
-
-inline void MadgraphPar::printParams() {
-
-  // Loop over all stored parameters and print
-  cout << endl
-       << " *--------  Madgraph parameters  --------*" << endl;
-  for (map<string,double>::iterator it = params.begin();
-       it != params.end(); ++it)
-    cout << " |  " << left << setw(15) << it->first
-         << "  |  " << right << setw(15) << it->second
-         << "  |" << endl;
-  cout << " *---------------------------------------*" << endl;
-}
-
-//--------------------------------------------------------------------------
-
-// Warn if a parameter is going to be overwriten
-
-inline void MadgraphPar::warnParamOverwrite(const string &paramIn,
-  double val) {
-
-  // Check if present and if new value is different
-  if (haveParam(paramIn) &&
-      abs(getParam(paramIn) - val) > ZEROTHRESHOLD) {
-    cout << "Warning in LHAupAlpgen::"
-         << "warnParamOverwrite: overwriting existing parameter"
-         << paramIn << endl;
-  }
-}
-
-//--------------------------------------------------------------------------
-
-// Simple string trimmer
-
-inline string MadgraphPar::trim(string s) {
-
-  // Remove whitespace in incoming string
-  size_t i;
-  if ( (i = s.find_last_not_of(" \t\r\n")) != string::npos)
-    s = s.substr(0, i + 1);
-  if ( (i = s.find_first_not_of(" \t\r\n")) != string::npos)
-    s = s.substr(i);
-  return s;
-}
-
-//==========================================================================
 
 } // end namespace Pythia8
 
diff -rupN pythia8306_original/include/Pythia8Plugins/JetMatching.h pythia8306_patched/include/Pythia8Plugins/JetMatching.h
--- pythia8306_original/include/Pythia8Plugins/JetMatching.h	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/include/Pythia8Plugins/JetMatching.h	2023-06-27 02:09:11.924196135 +0200
@@ -45,37 +45,6 @@
 
 };
 
-//--------------------------------------------------------------------------
-
-// Find next cluster pair to join.
-
-void HJSlowJet::findNext() {
-
-  // Find smallest of diB, dij.
-  if (clSize > 0) {
-    iMin =  0;
-    jMin = -1;
-    dMin = 1.0/TINY;
-    // Remove the possibility of choosing a beam clustering
-    for (int i = 1; i < clSize; ++i) {
-      for (int j = 0; j < i; ++j) {
-        if (dij[i*(i-1)/2 + j] < dMin) {
-          iMin = i;
-          jMin = j;
-          dMin = dij[i*(i-1)/2 + j];
-        }
-      }
-    }
-
-  // If no clusters left then instead default values.
-  } else {
-    iMin = -1;
-    jMin = -1;
-    dMin = 0.;
-  }
-
-}
-
 //==========================================================================
 
 // Declaration of main JetMatching class to perform MLM matching.
@@ -365,1684 +334,6 @@
 
 };
 
-//==========================================================================
-
-// Main implementation of JetMatching class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-//--------------------------------------------------------------------------
-
-// Constants to be changed for debug printout or extra checks.
-const bool JetMatching::MATCHINGDEBUG = false;
-const bool JetMatching::MATCHINGCHECK = false;
-
-//--------------------------------------------------------------------------
-
-// Early parton level veto (before beam remnants and resonance showers)
-
-inline bool JetMatching::doVetoPartonLevelEarly(const Event& event) {
-
-  // 1) Sort the original incoming process. After this step is performed,
-  //    the following assignments have been made:
-  //    eventProcessOrig - the original incoming process
-  //    eventProcess     - the final-state of the incoming process with
-  //                       resonance decays removed (and resonances
-  //                       themselves now with positive status code)
-  //    typeIdx[0/1/2]   - Indices into 'eventProcess' of
-  //                       light jets/heavy jets/other
-  //    typeSet[0/1/2]   - Indices into 'event' of light jets/heavy jets/other
-  //    workEvent        - partons from the hardest subsystem + ISR + FSR only
-  sortIncomingProcess(event);
-
-  // For the shower-kT scheme, do not perform any veto here, as any vetoing
-  // will already have taken place in doVetoStep.
-  if ( doShowerKt ) return false;
-
-  // Debug printout.
-  if (MATCHINGDEBUG) {
-    // Begin
-    cout << endl << "-------- Begin Madgraph Debug --------" << endl;
-    // Original incoming process
-    cout << endl << "Original incoming process:";
-    eventProcessOrig.list();
-    // Final-state of original incoming process
-    cout << endl << "Final-state incoming process:";
-    eventProcess.list();
-    // List categories of sorted particles
-    for (size_t i = 0; i < typeIdx[0].size(); i++)
-      cout << ((i == 0) ? "Light jets: " : ", ")   << setw(3) << typeIdx[0][i];
-    if( typeIdx[0].size()== 0 )
-      cout << "Light jets: None";
-
-    for (size_t i = 0; i < typeIdx[1].size(); i++)
-      cout << ((i == 0) ? "\nHeavy jets: " : ", ") << setw(3) << typeIdx[1][i];
-    for (size_t i = 0; i < typeIdx[2].size(); i++)
-      cout << ((i == 0) ? "\nOther:      " : ", ") << setw(3) << typeIdx[2][i];
-    // Full event at this stage
-    cout << endl << endl << "Event:";
-    event.list();
-    // Work event (partons from hardest subsystem + ISR + FSR)
-    cout << endl << "Work event:";
-    workEvent.list();
-  }
-
-  // 2) Light/heavy jets: iType = 0 (light jets), 1 (heavy jets)
-  int iTypeEnd = (typeIdx[2].empty()) ? 2 : 3;
-  for (int iType = 0; iType < iTypeEnd; iType++) {
-
-    // 2a) Find particles which will be passed from the jet algorithm.
-    //     Input from 'workEvent' and output in 'workEventJet'.
-    jetAlgorithmInput(event, iType);
-
-    // Debug printout.
-    if (MATCHINGDEBUG) {
-      // Jet algorithm event
-      cout << endl << "Jet algorithm event (iType = " << iType << "):";
-      workEventJet.list();
-    }
-
-    // 2b) Run jet algorithm on 'workEventJet'.
-    //     Output is stored in jetMomenta.
-    runJetAlgorithm();
-
-    // 2c) Match partons to jets and decide if veto is necessary
-    if (matchPartonsToJets(iType) == true) {
-      // Debug printout.
-      if (MATCHINGDEBUG) {
-        cout << endl << "Event vetoed" << endl
-             << "----------  End MLM Debug  ----------" << endl;
-      }
-      return true;
-    }
-  }
-
-  // Debug printout.
-  if (MATCHINGDEBUG) {
-    cout << endl << "Event accepted" << endl
-         << "----------  End MLM Debug  ----------" << endl;
-  }
-
-  // If we reached here, then no veto
-  return false;
-
-}
-
-//==========================================================================
-
-// Main implementation of Alpgen UserHooks class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-//--------------------------------------------------------------------------
-
-// Constants: could be changed here if desired, but normally should not.
-// These are of technical nature, as described for each.
-
-// The energy of ghost particles. For technical reasons, this cannot be
-// set arbitrarily low, see 'Particle::TINY' in 'Event.cc' for details.
-const double JetMatchingAlpgen::GHOSTENERGY   = 1e-15;
-
-// A zero threshold value for double comparisons.
-const double JetMatchingAlpgen::ZEROTHRESHOLD = 1e-10;
-
-//--------------------------------------------------------------------------
-
-// Function to sort typeIdx vectors into descending eT/pT order.
-// Uses a selection sort, as number of partons generally small
-// and so efficiency not a worry.
-
-inline void JetMatchingAlpgen::sortTypeIdx(vector < int > &vecIn) {
-  for (size_t i = 0; i < vecIn.size(); i++) {
-    size_t jMax = i;
-    double vMax = (jetAlgorithm == 1) ?
-      eventProcess[vecIn[i]].eT() :
-      eventProcess[vecIn[i]].pT();
-    for (size_t j = i + 1; j < vecIn.size(); j++) {
-      double vNow = (jetAlgorithm == 1)
-        ? eventProcess[vecIn[j]].eT() : eventProcess[vecIn[j]].pT();
-      if (vNow > vMax) {
-        vMax = vNow;
-        jMax = j;
-      }
-    }
-    if (jMax != i) swap(vecIn[i], vecIn[jMax]);
-  }
-}
-
-//--------------------------------------------------------------------------
-
-// Initialisation routine automatically called from Pythia::init().
-// Setup all parts needed for the merging.
-
-inline bool JetMatchingAlpgen::initAfterBeams() {
-
-  // Read in parameters
-  doMerge         = settingsPtr->flag("JetMatching:merge");
-  jetAlgorithm    = settingsPtr->mode("JetMatching:jetAlgorithm");
-  nJet            = settingsPtr->mode("JetMatching:nJet");
-  nJetMax         = settingsPtr->mode("JetMatching:nJetMax");
-  eTjetMin        = settingsPtr->parm("JetMatching:eTjetMin");
-  coneRadius      = settingsPtr->parm("JetMatching:coneRadius");
-  etaJetMax       = settingsPtr->parm("JetMatching:etaJetMax");
-  doShowerKt      = settingsPtr->flag("JetMatching:doShowerKt");
-
-  // Use etaJetMax + coneRadius in input to jet algorithms
-  etaJetMaxAlgo   = etaJetMax + coneRadius;
-
-  // CellJet specific
-  nEta            = settingsPtr->mode("JetMatching:nEta");
-  nPhi            = settingsPtr->mode("JetMatching:nPhi");
-  eTseed          = settingsPtr->parm("JetMatching:eTseed");
-  eTthreshold     = settingsPtr->parm("JetMatching:eTthreshold");
-
-  // SlowJet specific
-  slowJetPower    = settingsPtr->mode("JetMatching:slowJetPower");
-  coneMatchLight  = settingsPtr->parm("JetMatching:coneMatchLight");
-  coneRadiusHeavy = settingsPtr->parm("JetMatching:coneRadiusHeavy");
-  if (coneRadiusHeavy < 0.) coneRadiusHeavy = coneRadius;
-  coneMatchHeavy  = settingsPtr->parm("JetMatching:coneMatchHeavy");
-
-  // Matching procedure
-  jetAllow        = settingsPtr->mode("JetMatching:jetAllow");
-  jetMatch        = settingsPtr->mode("JetMatching:jetMatch");
-  exclusiveMode   = settingsPtr->mode("JetMatching:exclusive");
-
-  // If not merging, then done
-  if (!doMerge) return true;
-
-  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
-  if (exclusiveMode == 2) {
-
-    // No nJet or nJetMax, so default to exclusive mode
-    if (nJet < 0 || nJetMax < 0) {
-      errorMsg("Warning in JetMatchingAlpgen:init: "
-          "missing jet multiplicity information; running in exclusive mode");
-      exclusive = true;
-
-    // Inclusive if nJet == nJetMax, exclusive otherwise
-    } else {
-      exclusive = (nJet == nJetMax) ? false : true;
-    }
-
-  // Otherwise, just set as given
-  } else {
-    exclusive = (exclusiveMode == 0) ? false : true;
-  }
-
-  // Initialise chosen jet algorithm. CellJet.
-  if (jetAlgorithm == 1) {
-
-    // Extra options for CellJet. nSel = 1 means that all final-state
-    // particles are taken and we retain control of what to select.
-    // smear/resolution/upperCut are not used and are set to default values.
-    int    nSel = 2, smear = 0;
-    double resolution = 0.5, upperCut = 2.;
-    cellJet = new CellJet(etaJetMaxAlgo, nEta, nPhi, nSel,
-                          smear, resolution, upperCut, eTthreshold);
-
-  // SlowJet
-  } else if (jetAlgorithm == 2) {
-    slowJet = new SlowJet(slowJetPower, coneRadius, eTjetMin, etaJetMaxAlgo);
-  }
-
-  // Check the jetMatch parameter; option 2 only works with SlowJet
-  if (jetAlgorithm == 1 && jetMatch == 2) {
-    errorMsg("Warning in JetMatchingAlpgen:init: "
-        "jetMatch = 2 only valid with SlowJet algorithm. "
-        "Reverting to jetMatch = 1");
-    jetMatch = 1;
-  }
-
-  // Setup local event records
-  eventProcessOrig.init("(eventProcessOrig)", particleDataPtr);
-  eventProcess.init("(eventProcess)", particleDataPtr);
-  workEventJet.init("(workEventJet)", particleDataPtr);
-
-  // Print information
-  string jetStr  = (jetAlgorithm ==  1) ? "CellJet" :
-                   (slowJetPower == -1) ? "anti-kT" :
-                   (slowJetPower ==  0) ? "C/A"     :
-                   (slowJetPower ==  1) ? "kT"      : "unknown";
-  string modeStr = (exclusive)         ? "exclusive" : "inclusive";
-  stringstream nJetStr, nJetMaxStr;
-  if (nJet >= 0)    nJetStr    << nJet;    else nJetStr    << "unknown";
-  if (nJetMax >= 0) nJetMaxStr << nJetMax; else nJetMaxStr << "unknown";
-  cout << endl
-       << " *-------  MLM matching parameters  -------*" << endl
-       << " |  nJet                |  " << setw(14)
-       << nJetStr.str() << "  |" << endl
-       << " |  nJetMax             |  " << setw(14)
-       << nJetMaxStr.str() << "  |" << endl
-       << " |  Jet algorithm       |  " << setw(14)
-       << jetStr << "  |" << endl
-       << " |  eTjetMin            |  " << setw(14)
-       << eTjetMin << "  |" << endl
-       << " |  coneRadius          |  " << setw(14)
-       << coneRadius << "  |" << endl
-       << " |  etaJetMax           |  " << setw(14)
-       << etaJetMax << "  |" << endl
-       << " |  jetAllow            |  " << setw(14)
-       << jetAllow << "  |" << endl
-       << " |  jetMatch            |  " << setw(14)
-       << jetMatch << "  |" << endl
-       << " |  coneMatchLight      |  " << setw(14)
-       << coneMatchLight << "  |" << endl
-       << " |  coneRadiusHeavy     |  " << setw(14)
-       << coneRadiusHeavy << "  |" << endl
-       << " |  coneMatchHeavy      |  " << setw(14)
-       << coneMatchHeavy << "  |" << endl
-       << " |  Mode                |  " << setw(14)
-       << modeStr << "  |" << endl
-       << " *-----------------------------------------*" << endl;
-
-  return true;
-}
-
-//--------------------------------------------------------------------------
-
-// Step (1): sort the incoming particles
-
-inline void JetMatchingAlpgen::sortIncomingProcess(const Event &event) {
-
-  // Remove resonance decays from original process and keep only final
-  // state. Resonances will have positive status code after this step.
-  omitResonanceDecays(eventProcessOrig, true);
-  eventProcess = workEvent;
-
-  // Sort original process final state into light/heavy jets and 'other'.
-  // Criteria:
-  //   1 <= ID <= 5 and massless, or ID == 21 --> light jet (typeIdx[0])
-  //   4 <= ID <= 6 and massive               --> heavy jet (typeIdx[1])
-  //   All else                               --> other     (typeIdx[2])
-  // Note that 'typeIdx' stores indices into 'eventProcess' (after resonance
-  // decays are omitted), while 'typeSet' stores indices into the original
-  // process record, 'eventProcessOrig', but these indices are also valid
-  // in 'event'.
-  for (int i = 0; i < 3; i++) {
-    typeIdx[i].clear();
-    typeSet[i].clear();
-  }
-  for (int i = 0; i < eventProcess.size(); i++) {
-    // Ignore nonfinal and default to 'other'
-    if (!eventProcess[i].isFinal()) continue;
-    int idx = 2;
-
-    // Light jets
-    if (eventProcess[i].id() == ID_GLUON
-      || (eventProcess[i].idAbs() <= ID_BOT
-      && abs(eventProcess[i].m()) < ZEROTHRESHOLD)) idx = 0;
-
-    // Heavy jets
-    else if (eventProcess[i].idAbs() >= ID_CHARM
-      && eventProcess[i].idAbs() <= ID_TOP) idx = 1;
-
-    // Store
-    typeIdx[idx].push_back(i);
-    typeSet[idx].insert(eventProcess[i].daughter1());
-  }
-
-  // Extract partons from hardest subsystem + ISR + FSR only into
-  // workEvent. Note no resonance showers or MPIs.
-  subEvent(event);
-}
-
-//--------------------------------------------------------------------------
-
-// Step (2a): pick which particles to pass to the jet algorithm
-
-inline void JetMatchingAlpgen::jetAlgorithmInput(const Event &event,
-  int iType) {
-
-  // Take input from 'workEvent' and put output in 'workEventJet'
-  workEventJet = workEvent;
-
-  // Loop over particles and decide what to pass to the jet algorithm
-  for (int i = 0; i < workEventJet.size(); ++i) {
-    if (!workEventJet[i].isFinal()) continue;
-
-    // jetAllow option to disallow certain particle types
-    if (jetAllow == 1) {
-
-      // Original AG+Py6 algorithm explicitly excludes tops,
-      // leptons and photons.
-      int id = workEventJet[i].idAbs();
-      if ( (id >= ID_LEPMIN && id <= ID_LEPMAX) || id == ID_TOP
-        || id == ID_PHOTON) {
-        workEventJet[i].statusNeg();
-        continue;
-      }
-    }
-
-    // Get the index of this particle in original event
-    int idx = workEventJet[i].daughter1();
-
-    // Start with particle idx, and afterwards track mothers
-    while (true) {
-
-      // Light jets
-      if (iType == 0) {
-
-        // Do not include if originates from heavy jet or 'other'
-        if (typeSet[1].find(idx) != typeSet[1].end() ||
-            typeSet[2].find(idx) != typeSet[2].end()) {
-          workEventJet[i].statusNeg();
-          break;
-        }
-
-        // Made it to start of event record so done
-        if (idx == 0) break;
-        // Otherwise next mother and continue
-        idx = event[idx].mother1();
-
-      // Heavy jets
-      } else if (iType == 1) {
-
-        // Only include if originates from heavy jet
-        if (typeSet[1].find(idx) != typeSet[1].end()) break;
-
-        // Made it to start of event record with no heavy jet mother,
-        // so DO NOT include particle
-        if (idx == 0) {
-          workEventJet[i].statusNeg();
-          break;
-        }
-
-        // Otherwise next mother and continue
-        idx = event[idx].mother1();
-
-      // Other jets
-      } else if (iType == 2) {
-
-        // Only include if originates from other jet
-        if (typeSet[2].find(idx) != typeSet[2].end()) break;
-
-        // Made it to start of event record with no heavy jet mother,
-        // so DO NOT include particle
-        if (idx == 0) {
-          workEventJet[i].statusNeg();
-          break;
-        }
-
-        // Otherwise next mother and continue
-        idx = event[idx].mother1();
-
-      } // if (iType)
-    } // while (true)
-  } // for (i)
-
-  // For jetMatch = 2, insert ghost particles corresponding to
-  // each hard parton in the original process
-  if (jetMatch == 2) {
-    for (int i = 0; i < int(typeIdx[iType].size()); i++) {
-      // Get y/phi of the parton
-      Vec4   pIn = eventProcess[typeIdx[iType][i]].p();
-      double y   = pIn.rap();
-      double phi = pIn.phi();
-
-      // Create a ghost particle and add to the workEventJet
-      double e   = GHOSTENERGY;
-      double e2y = exp(2. * y);
-      double pz  = e * (e2y - 1.) / (e2y + 1.);
-      double pt  = sqrt(e*e - pz*pz);
-      double px  = pt * cos(phi);
-      double py  = pt * sin(phi);
-      workEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0, px, py, pz, e);
-
-      // Extra check on reconstructed y/phi values. If many warnings
-      // of this type, GHOSTENERGY may be set too low.
-      if (MATCHINGCHECK) {
-      int lastIdx = workEventJet.size() - 1;
-      if (abs(y   - workEventJet[lastIdx].y())   > ZEROTHRESHOLD ||
-          abs(phi - workEventJet[lastIdx].phi()) > ZEROTHRESHOLD)
-        errorMsg("Warning in JetMatchingAlpgen:jetAlgorithmInput: "
-            "ghost particle y/phi mismatch");
-      }
-
-    } // for (i)
-  } // if (jetMatch == 2)
-}
-
-//--------------------------------------------------------------------------
-
-// Step (2b): run jet algorithm and provide common output
-
-inline void JetMatchingAlpgen::runJetAlgorithm() {
-
-  // Run the jet clustering algorithm
-  if (jetAlgorithm == 1)
-    cellJet->analyze(workEventJet, eTjetMin, coneRadius, eTseed);
-  else
-    slowJet->analyze(workEventJet);
-
-  // Extract four-momenta of jets with |eta| < etaJetMax and
-  // put into jetMomenta. Note that this is done backwards as
-  // jets are removed with SlowJet.
-  jetMomenta.clear();
-  int iJet = (jetAlgorithm == 1) ? cellJet->size() - 1:
-                                   slowJet->sizeJet() - 1;
-  for (int i = iJet; i > -1; i--) {
-    Vec4 jetMom = (jetAlgorithm == 1) ? cellJet->pMassive(i) :
-                                        slowJet->p(i);
-    double eta = jetMom.eta();
-
-    if (abs(eta) > etaJetMax) {
-      if (jetAlgorithm == 2) slowJet->removeJet(i);
-      continue;
-    }
-    jetMomenta.push_back(jetMom);
-  }
-
-  // Reverse jetMomenta to restore eT/pT ordering
-  reverse(jetMomenta.begin(), jetMomenta.end());
-}
-
-//--------------------------------------------------------------------------
-
-// Step (2c): veto decision (returning true vetoes the event)
-
-inline bool JetMatchingAlpgen::matchPartonsToJets(int iType) {
-
-  // Use two different routines for light/heavy jets as
-  // different veto conditions and for clarity
-  if (iType == 0) return (matchPartonsToJetsLight() > 0);
-  else if (iType == 1) return (matchPartonsToJetsHeavy() > 0);
-  else if (iType == 2) return false;
-  return true;
-}
-
-//--------------------------------------------------------------------------
-
-// Step(2c): light jets
-// Return codes are given indicating the reason for a veto.
-// Although not currently used, they are a useful debugging tool:
-//   0 = no veto
-//   1 = veto as number of jets less than number of partons
-//   2 = veto as exclusive mode and number of jets greater than
-//       number of partons
-//   3 = veto as inclusive mode and there would be an extra jet
-//       that is harder than any matched soft jet
-//   4 = veto as there is a parton which does not match a jet
-
-inline int JetMatchingAlpgen::matchPartonsToJetsLight() {
-
-  // Always veto if number of jets is less than original number of jets
-  if (jetMomenta.size() < typeIdx[0].size()) return LESS_JETS;
-  // Veto if in exclusive mode and number of jets bigger than original
-  if (exclusive && jetMomenta.size() > typeIdx[0].size()) return MORE_JETS;
-
-  // Sort partons by eT/pT
-  sortTypeIdx(typeIdx[0]);
-
-  // Number of hard partons
-  int nParton = typeIdx[0].size();
-
-  // Keep track of which jets have been assigned a hard parton
-  vector < bool > jetAssigned;
-  jetAssigned.assign(jetMomenta.size(), false);
-
-  // Jet matching procedure: (1) deltaR between partons and jets
-  if (jetMatch == 1) {
-
-    // Loop over light hard partons and get 4-momentum
-    for (int i = 0; i < nParton; i++) {
-      Vec4 p1 = eventProcess[typeIdx[0][i]].p();
-
-      // Track which jet has the minimal dR measure with this parton
-      int    jMin  = -1;
-      double dRmin = 0.;
-
-      // Loop over all jets (skipping those already assigned).
-      for (int j = 0; j < int(jetMomenta.size()); j++) {
-        if (jetAssigned[j]) continue;
-
-        // DeltaR between parton/jet and store if minimum
-        double dR = (jetAlgorithm == 1)
-          ? REtaPhi(p1, jetMomenta[j]) : RRapPhi(p1, jetMomenta[j]);
-        if (jMin < 0 || dR < dRmin) {
-          dRmin = dR;
-          jMin  = j;
-        }
-      } // for (j)
-
-      // Check for jet-parton match
-      if (jMin >= 0 && dRmin < coneRadius * coneMatchLight) {
-
-        // If the matched jet is not one of the nParton hardest jets,
-        // the extra left over jet would be harder than some of the
-        // matched jets. This is disallowed, so veto.
-        if (jMin >= nParton) return HARD_JET;
-
-        // Mark jet as assigned.
-        jetAssigned[jMin] = true;
-
-      // If no match, then event will be vetoed in all cases
-      } else return UNMATCHED_PARTON;
-
-    } // for (i)
-
-  // Jet matching procedure: (2) ghost particles in SlowJet
-  } else {
-
-    // Loop over added 'ghost' particles and find if assigned to a jet
-    for (int i = workEventJet.size() - nParton;
-        i < workEventJet.size(); i++) {
-      int jMin = slowJet->jetAssignment(i);
-
-      // Veto if:
-      //  1) not one of nParton hardest jets
-      //  2) not assigned to a jet
-      //  3) jet has already been assigned
-      if (jMin >= nParton)               return HARD_JET;
-      if (jMin < 0 || jetAssigned[jMin]) return UNMATCHED_PARTON;
-
-      // Mark jet as assigned
-      jetAssigned[jMin] = true;
-
-    } // for (i)
-  } // if (jetMatch)
-
-  // Minimal eT/pT (CellJet/SlowJet) of matched light jets. Needed
-  // later for heavy jet vetos in inclusive mode.
-  if (nParton > 0)
-    eTpTlightMin = (jetAlgorithm == 1) ? jetMomenta[nParton - 1].eT()
-                                       : jetMomenta[nParton - 1].pT();
-  else
-    eTpTlightMin = -1.;
-
-  // No veto
-  return NONE;
-}
-
-//--------------------------------------------------------------------------
-
-// Step(2c): heavy jets
-// Return codes are given indicating the reason for a veto.
-// Although not currently used, they are a useful debugging tool:
-//   0 = no veto as there are no extra jets present
-//   1 = veto as in exclusive mode and extra jets present
-//   2 = veto as in inclusive mode and extra jets were harder
-//       than any matched light jet
-
-inline int JetMatchingAlpgen::matchPartonsToJetsHeavy() {
-
-  // If there are no extra jets, then accept
-  if (jetMomenta.empty()) return NONE;
-
-  // Number of hard partons
-  int nParton = typeIdx[1].size();
-
-  // Remove jets that are close to heavy quarks
-  set < int > removeJets;
-
-  // Jet matching procedure: (1) deltaR between partons and jets
-  if (jetMatch == 1) {
-
-    // Loop over heavy hard partons and get 4-momentum
-    for (int i = 0; i < nParton; i++) {
-      Vec4 p1 = eventProcess[typeIdx[1][i]].p();
-
-      // Loop over all jets, find dR and mark for removal if match
-      for (int j = 0; j < int(jetMomenta.size()); j++) {
-        double dR = (jetAlgorithm == 1) ?
-            REtaPhi(p1, jetMomenta[j]) : RRapPhi(p1, jetMomenta[j]);
-        if (dR < coneRadiusHeavy * coneMatchHeavy)
-          removeJets.insert(j);
-
-      } // for (j)
-    } // for (i)
-
-  // Jet matching procedure: (2) ghost particles in SlowJet
-  } else {
-
-    // Loop over added 'ghost' particles and if assigned to a jet
-    // then mark this jet for removal
-    for (int i = workEventJet.size() - nParton;
-        i < workEventJet.size(); i++) {
-      int jMin = slowJet->jetAssignment(i);
-      if (jMin >= 0) removeJets.insert(jMin);
-    }
-
-  }
-
-  // Remove jets (backwards order to not disturb indices)
-  for (set < int >::reverse_iterator it  = removeJets.rbegin();
-                                     it != removeJets.rend(); it++)
-    jetMomenta.erase(jetMomenta.begin() + *it);
-
-  // Handle case if there are still extra jets
-  if (!jetMomenta.empty()) {
-
-    // Exclusive mode, so immediate veto
-    if (exclusive) return MORE_JETS;
-
-    // Inclusive mode; extra jets must be softer than any matched light jet
-    else if (eTpTlightMin >= 0.)
-      for (size_t j = 0; j < jetMomenta.size(); j++) {
-        // CellJet uses eT, SlowJet uses pT
-        if ( (jetAlgorithm == 1 && jetMomenta[j].eT() > eTpTlightMin) ||
-             (jetAlgorithm == 2 && jetMomenta[j].pT() > eTpTlightMin) )
-          return HARD_JET;
-      }
-
-  } // if (!jetMomenta.empty())
-
-  // No extra jets were present so no veto
-  return NONE;
-}
-
-//==========================================================================
-
-// Main implementation of Madgraph UserHooks class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-//--------------------------------------------------------------------------
-
-// Initialisation routine automatically called from Pythia::init().
-// Setup all parts needed for the merging.
-
-inline bool JetMatchingMadgraph::initAfterBeams() {
-
-  // Initialise values for stored jet matching veto inputs.
-  pTfirstSave = -1.;
-  processSubsetSave.init("(eventProcess)", particleDataPtr);
-  workEventJetSave.init("(workEventJet)", particleDataPtr);
-
-  // Read in Madgraph specific configuration variables
-  bool setMad    = settingsPtr->flag("JetMatching:setMad");
-
-  // If Madgraph parameters are present, then parse in MadgraphPar object
-  MadgraphPar par;
-  string parStr = infoPtr->header("MGRunCard");
-  if (!parStr.empty()) {
-    par.parse(parStr);
-    par.printParams();
-  }
-
-  // Set Madgraph merging parameters from the file if requested
-  if (setMad) {
-    if ( par.haveParam("xqcut")    && par.haveParam("maxjetflavor")
-      && par.haveParam("alpsfact") && par.haveParam("ickkw") ) {
-      settingsPtr->flag("JetMatching:merge", par.getParam("ickkw"));
-      settingsPtr->parm("JetMatching:qCut", par.getParam("xqcut"));
-      settingsPtr->mode("JetMatching:nQmatch",
-        par.getParamAsInt("maxjetflavor"));
-      settingsPtr->parm("JetMatching:clFact",
-        clFact = par.getParam("alpsfact"));
-      if (par.getParamAsInt("ickkw") == 0)
-        errorMsg("Error in JetMatchingMadgraph:init: "
-          "Madgraph file parameters are not set for merging");
-
-    // Warn if setMad requested, but one or more parameters not present
-    } else {
-       errorMsg("Warning in JetMatchingMadgraph:init: "
-          "Madgraph merging parameters not found");
-       if (!par.haveParam("xqcut")) errorMsg("Warning in "
-          "JetMatchingMadgraph:init: No xqcut");
-       if (!par.haveParam("ickkw")) errorMsg("Warning in "
-          "JetMatchingMadgraph:init: No ickkw");
-       if (!par.haveParam("maxjetflavor")) errorMsg("Warning in "
-          "JetMatchingMadgraph:init: No maxjetflavor");
-       if (!par.haveParam("alpsfact")) errorMsg("Warning in "
-          "JetMatchingMadgraph:init: No alpsfact");
-    }
-  }
-
-  // Read in FxFx matching parameters
-  doFxFx       = settingsPtr->flag("JetMatching:doFxFx");
-  nPartonsNow  = settingsPtr->mode("JetMatching:nPartonsNow");
-  qCutME       = settingsPtr->parm("JetMatching:qCutME");
-  qCutMESq     = pow(qCutME,2);
-
-  // Read in Madgraph merging parameters
-  doMerge      = settingsPtr->flag("JetMatching:merge");
-  doShowerKt   = settingsPtr->flag("JetMatching:doShowerKt");
-  qCut         = settingsPtr->parm("JetMatching:qCut");
-  nQmatch      = settingsPtr->mode("JetMatching:nQmatch");
-  clFact       = settingsPtr->parm("JetMatching:clFact");
-
-  // Read in jet algorithm parameters
-  jetAlgorithm   = settingsPtr->mode("JetMatching:jetAlgorithm");
-  nJetMax        = settingsPtr->mode("JetMatching:nJetMax");
-  eTjetMin       = settingsPtr->parm("JetMatching:eTjetMin");
-  coneRadius     = settingsPtr->parm("JetMatching:coneRadius");
-  etaJetMax      = settingsPtr->parm("JetMatching:etaJetMax");
-  slowJetPower   = settingsPtr->mode("JetMatching:slowJetPower");
-
-  // Matching procedure
-  jetAllow       = settingsPtr->mode("JetMatching:jetAllow");
-  exclusiveMode  = settingsPtr->mode("JetMatching:exclusive");
-  qCutSq         = pow(qCut,2);
-  etaJetMaxAlgo  = etaJetMax;
-
-  // Read if veto should be performed internally.
-  performVeto    = settingsPtr->flag("JetMatching:doVeto");
-
-  // If not merging, then done
-  if (!doMerge) return true;
-
-  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
-  if (exclusiveMode == 2) {
-
-    // No nJet or nJetMax, so default to exclusive mode
-    if (nJetMax < 0) {
-      errorMsg("Warning in JetMatchingMadgraph:init: "
-        "missing jet multiplicity information; running in exclusive mode");
-      exclusiveMode = 1;
-    }
-  }
-
-  // Initialise chosen jet algorithm.
-  // Currently, this only supports the kT-algorithm in SlowJet.
-  // Use the QCD distance measure by default.
-  jetAlgorithm = 2;
-  slowJetPower = 1;
-  slowJet = new SlowJet(slowJetPower, coneRadius, eTjetMin,
-    etaJetMaxAlgo, 2, 2, NULL, false);
-
-  // For FxFx, also initialise jet algorithm to define matrix element jets.
-  // Currently, this only supports the kT-algorithm in SlowJet.
-  // Use the QCD distance measure by default.
-  slowJetHard = new SlowJet(slowJetPower, coneRadius, qCutME,
-    etaJetMaxAlgo, 2, 2, NULL, false);
-
-  // To access the DJR's
-  slowJetDJR = new SlowJet(slowJetPower, coneRadius, qCutME,
-    etaJetMaxAlgo, 2, 2, NULL, false);
-
-  // A special version of SlowJet to handle heavy and other partons
-  hjSlowJet = new HJSlowJet(slowJetPower, coneRadius, 0.0,
-    100.0, 1, 2, NULL, false, true);
-
-  // Setup local event records
-  eventProcessOrig.init("(eventProcessOrig)", particleDataPtr);
-  eventProcess.init("(eventProcess)", particleDataPtr);
-  workEventJet.init("(workEventJet)", particleDataPtr);
-
-  // Print information
-  string jetStr  = (jetAlgorithm ==  1) ? "CellJet" :
-                   (slowJetPower == -1) ? "anti-kT" :
-                   (slowJetPower ==  0) ? "C/A"     :
-                   (slowJetPower ==  1) ? "kT"      : "unknown";
-  string modeStr = (exclusiveMode)         ? "exclusive" : "inclusive";
-  cout << endl
-       << " *-----  Madgraph matching parameters  -----*" << endl
-       << " |  qCut                |  " << setw(14)
-       << qCut << "  |" << endl
-       << " |  nQmatch             |  " << setw(14)
-       << nQmatch << "  |" << endl
-       << " |  clFact              |  " << setw(14)
-       << clFact << "  |" << endl
-       << " |  Jet algorithm       |  " << setw(14)
-       << jetStr << "  |" << endl
-       << " |  eTjetMin            |  " << setw(14)
-       << eTjetMin << "  |" << endl
-       << " |  etaJetMax           |  " << setw(14)
-       << etaJetMax << "  |" << endl
-       << " |  jetAllow            |  " << setw(14)
-       << jetAllow << "  |" << endl
-       << " |  Mode                |  " << setw(14)
-       << modeStr << "  |" << endl
-       << " *-----------------------------------------*" << endl;
-
-  return true;
-}
-
-//--------------------------------------------------------------------------
-
-// Process level vetos
-
-inline bool JetMatchingMadgraph::doVetoProcessLevel(Event& process) {
-
-  eventProcessOrig = process;
-
-  // Setup for veto if hard ME has too many partons.
-  // This is done to achieve consistency with the Pythia6 implementation.
-
-  // Clear the event of MPI systems and resonace decay products. Store trimmed
-  // event in workEvent.
-  sortIncomingProcess(process);
-
-  // Veto in case the hard input matrix element already has too many partons.
-  if ( !doFxFx && int(typeIdx[0].size()) > nJetMax )
-    return true;
-  if ( doFxFx && npNLO() < nJetMax && int(typeIdx[0].size()) > nJetMax )
-    return true;
-
-  // Done
-  return false;
-
-}
-
-//--------------------------------------------------------------------------
-
-inline bool JetMatchingMadgraph::doVetoStep(int iPos, int nISR, int nFSR,
-  const Event& event)  {
-
-  // Do not perform any veto if not in the Shower-kT scheme.
-  if ( !doShowerKt ) return false;
-
-  // Do nothing for emissions after the first one.
-  if ( nISR + nFSR > 1 ) return false;
-
-  // Do nothing in resonance decay showers.
-  if (iPos == 5) return false;
-
-  // Clear the event of MPI systems and resonace decay products. Store trimmed
-  // event in workEvent.
-  sortIncomingProcess(event);
-
-  // Get (kinematical) pT of first emission
-  double pTfirst = 0.;
-
-  // Get weak bosons, for later checks if the emission is a "QCD emission".
-  vector<int> weakBosons;
-  for (int i = 0; i < event.size(); i++) {
-    if ( event[i].id() == 22
-      && event[i].id() == 23
-      && event[i].idAbs() == 24)
-      weakBosons.push_back(i);
-  }
-
-  for (int i =  workEvent.size()-1; i > 0; --i) {
-    if ( workEvent[i].isFinal() && workEvent[i].colType() != 0
-      && (workEvent[i].statusAbs() == 43 || workEvent[i].statusAbs() == 51)) {
-      // Check if any of the EW bosons are ancestors of this parton. This
-      // should never happen for the first non-resonance shower emission.
-      // Check just to be sure.
-      bool QCDemission = true;
-      // Get position of this parton in the actual event (workEvent does
-      // not contain right mother-daughter relations). Stored in daughters.
-      int iPosOld = workEvent[i].daughter1();
-      for (int j = 0; i < int(weakBosons.size()); ++i)
-        if ( event[iPosOld].isAncestor(j)) {
-          QCDemission = false;
-          break;
-        }
-      // Done for a QCD emission.
-      if (QCDemission){
-        pTfirst = workEvent[i].pT();
-        break;
-      }
-    }
-  }
-
-  // Store things that are necessary to perform the shower-kT veto externally.
-  pTfirstSave   = pTfirst;
-  // Done if only inputs for an external vetoing procedure should be stored.
-  if (!performVeto) return false;
-
-  // Check veto.
-  if ( doShowerKtVeto(pTfirst) ) return true;
-
-  // No veto if come this far.
-  return false;
-
-}
-
-//--------------------------------------------------------------------------
-
-inline bool JetMatchingMadgraph::doShowerKtVeto(double pTfirst) {
-
-  // Only check veto in the shower-kT scheme.
-  if ( !doShowerKt ) return false;
-
-  // Reset veto code
-  bool doVeto = false;
-
-  // Find the (kinematical) pT of the softest (light) parton in the hard
-  // process.
-  int nParton = typeIdx[0].size();
-  double pTminME=1e10;
-  for ( int i = 0; i < nParton; ++i)
-    pTminME = min(pTminME,eventProcess[typeIdx[0][i]].pT());
-
-  // Veto if the softest hard process parton is below Qcut.
-  if ( nParton > 0 && pow(pTminME,2) < qCutSq ) doVeto = true;
-
-  // For non-highest multiplicity, veto if the hardest emission is harder
-  // than Qcut.
-  if ( exclusive && pow(pTfirst,2) > qCutSq ) {
-    doVeto = true;
-  // For highest multiplicity sample, veto if the hardest emission is harder
-  // than the hard process parton.
-  } else if ( !exclusive && nParton > 0 && pTfirst > pTminME ) {
-    doVeto = true;
-  }
-
-  // Return veto
-  return doVeto;
-
-}
-
-//--------------------------------------------------------------------------
-
-// Function to set the jet clustering scales (to be used as output)
-
-inline void JetMatchingMadgraph::setDJR( const Event& event) {
-
- // Clear members.
- clearDJR();
- vector<double> result;
-
-  // Initialize SlowJetDJR jet algorithm with event
-  if (!slowJetDJR->setup(event) ) {
-    errorMsg("Warning in JetMatchingMadgraph:setDJR"
-      ": the SlowJet algorithm failed on setup");
-    return;
-  }
-
-  // Cluster in steps to find all hadronic jets
-  while ( slowJetDJR->sizeAll() - slowJetDJR->sizeJet() > 0 ) {
-    // Save the next clustering scale.
-    result.push_back(sqrt(slowJetDJR->dNext()));
-    // Perform step.
-    slowJetDJR->doStep();
-  }
-
-  // Save clustering scales in reserve order.
-  for (int i=int(result.size())-1; i >= 0; --i)
-    DJR.push_back(result[i]);
-
-}
-
-//--------------------------------------------------------------------------
-
-// Function to get the current number of partons in the Born state, as
-// read from LHE.
-
-inline int JetMatchingMadgraph::npNLO(){
-  string npIn = infoPtr->getEventAttribute("npNLO",true);
-  int np = (npIn != "") ? atoi((char*)npIn.c_str()) : -1;
-  if ( np < 0 ) { ; }
-  else return np;
-  return nPartonsNow;
-}
-
-//--------------------------------------------------------------------------
-
-// Step (1): sort the incoming particles
-
-inline void JetMatchingMadgraph::sortIncomingProcess(const Event &event) {
-
-  // Remove resonance decays from original process and keep only final
-  // state. Resonances will have positive status code after this step.
-  omitResonanceDecays(eventProcessOrig, true);
-  clearDJR();
-  clear_nMEpartons();
-
-  // For FxFx, pre-cluster partons in the event into jets.
-  if (doFxFx) {
-
-    // Get final state partons
-    eventProcess.clear();
-    workEventJet.clear();
-    for( int i=0; i < workEvent.size(); ++i) {
-      // Original AG+Py6 algorithm explicitly excludes tops,
-      // leptons and photons.
-      int id = workEvent[i].idAbs();
-      if ((id >= ID_LEPMIN && id <= ID_LEPMAX) || id == ID_TOP
-        || id == ID_PHOTON || id == 23 || id == 24 || id == 25) {
-        eventProcess.append(workEvent[i]);
-      } else {
-        workEventJet.append(workEvent[i]);
-      }
-    }
-
-    // Initialize SlowJetHard jet algorithm with current working event
-    if (!slowJetHard->setup(workEventJet) ) {
-      errorMsg("Warning in JetMatchingMadgraph:sortIncomingProcess"
-        ": the SlowJet algorithm failed on setup");
-      return;
-    }
-
-    // Get matrix element cut scale.
-    double localQcutSq = qCutMESq;
-    // Cluster in steps to find all hadronic jets at the scale qCutME
-    while ( slowJetHard->sizeAll() - slowJetHard->sizeJet() > 0 ) {
-      // Done if next step is above qCut
-      if( slowJetHard->dNext() > localQcutSq ) break;
-      // Done if we're at or below the number of partons in the Born state.
-      if( slowJetHard->sizeAll()-slowJetHard->sizeJet() <= npNLO()) break;
-      slowJetHard->doStep();
-    }
-
-    // Construct a master copy of the event containing only the
-    // hardest nPartonsNow hadronic clusters. While constructing the event,
-    // the parton type (ID_GLUON) and status (98,99) are arbitrary.
-    int nJets = slowJetHard->sizeJet();
-    int nClus = slowJetHard->sizeAll();
-    int nNow = 0;
-    for (int i = nJets; i < nClus; ++i) {
-      vector<int> parts;
-      if (i < nClus-nJets) parts = slowJetHard->clusConstituents(i);
-      else parts = slowJetHard->constituents(nClus-nJets-i);
-      int flavour = ID_GLUON;
-      for(int j=0; j < int(parts.size()); ++j)
-        if (workEventJet[parts[j]].id() == ID_BOT)
-          flavour = ID_BOT;
-      eventProcess.append( flavour, 98,
-        workEventJet[parts.back()].mother1(),
-        workEventJet[parts.back()].mother2(),
-        workEventJet[parts.back()].daughter1(),
-        workEventJet[parts.back()].daughter2(),
-        0, 0, slowJetHard->p(i).px(), slowJetHard->p(i).py(),
-        slowJetHard->p(i).pz(), slowJetHard->p(i).e() );
-      nNow++;
-    }
-
-    // Done. Clean-up
-    workEventJet.clear();
-
-  // For MLM matching, simply take hard process state from workEvent,
-  // without any preclustering.
-  } else {
-    eventProcess = workEvent;
-  }
-
-  // Sort original process final state into light/heavy jets and 'other'.
-  // Criteria:
-  //   1 <= ID <= nQmatch, or ID == 21         --> light jet (typeIdx[0])
-  //   nQMatch < ID                            --> heavy jet (typeIdx[1])
-  //   All else that is colored                --> other     (typeIdx[2])
-  // Note that 'typeIdx' stores indices into 'eventProcess' (after resonance
-  // decays are omitted), while 'typeSet' stores indices into the original
-  // process record, 'eventProcessOrig', but these indices are also valid
-  // in 'event'.
-  for (int i = 0; i < 3; i++) {
-    typeIdx[i].clear();
-    typeSet[i].clear();
-    origTypeIdx[i].clear();
-  }
-  for (int i = 0; i < eventProcess.size(); i++) {
-    // Ignore non-final state and default to 'other'
-    if (!eventProcess[i].isFinal()) continue;
-    int idx = -1;
-    int orig_idx = -1;
-
-    // Light jets: all gluons and quarks with id less than or equal to nQmatch
-    if (eventProcess[i].isGluon()
-      || (eventProcess[i].idAbs() <= nQmatch) ) {
-      orig_idx = 0;
-      // Crucial point: MG puts the scale of a non-QCD particle to eCM. For
-      // such particles, we should keep the default "2"
-      idx = ( eventProcess[i].scale() < 1.999 * sqrt(infoPtr->eA()
-        * infoPtr->eB()) ) ? 0 : 2;
-    }
-
-    // Heavy jets:  all quarks with id greater than nQmatch
-    else if (eventProcess[i].idAbs() > nQmatch
-      && eventProcess[i].idAbs() <= ID_TOP) {
-      idx = 1;
-      orig_idx = 1;
-    // Update to include non-SM colored particles
-    } else if (eventProcess[i].colType() != 0
-      && eventProcess[i].idAbs() > ID_TOP) {
-      idx = 1;
-      orig_idx = 1;
-    }
-    if( idx < 0 ) continue;
-    // Store
-    typeIdx[idx].push_back(i);
-    typeSet[idx].insert(eventProcess[i].daughter1());
-    origTypeIdx[orig_idx].push_back(i);
-  }
-
-  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
-  if (exclusiveMode == 2) {
-
-    // Inclusive if nJet == nJetMax, exclusive otherwise
-    int nParton = origTypeIdx[0].size();
-    exclusive = (nParton == nJetMax) ? false : true;
-
-  // Otherwise, just set as given
-  } else {
-    exclusive = (exclusiveMode == 0) ? false : true;
-  }
-
-  // Extract partons from hardest subsystem + ISR + FSR only into
-  // workEvent. Note no resonance showers or MPIs.
-  subEvent(event);
-
-  // Store things that are necessary to perform the kT-MLM veto externally.
-  int nParton = typeIdx[0].size();
-  processSubsetSave.clear();
-  for ( int i = 0; i < nParton; ++i)
-    processSubsetSave.append( eventProcess[typeIdx[0][i]] );
-
-}
-
-//--------------------------------------------------------------------------
-
-// Step (2a): pick which particles to pass to the jet algorithm
-
-inline void JetMatchingMadgraph::jetAlgorithmInput(const Event &event,
-  int iType) {
-
-  // Take input from 'workEvent' and put output in 'workEventJet'
-  workEventJet = workEvent;
-
-  // Loop over particles and decide what to pass to the jet algorithm
-  for (int i = 0; i < workEventJet.size(); ++i) {
-    if (!workEventJet[i].isFinal()) continue;
-
-    // jetAllow option to disallow certain particle types
-    if (jetAllow == 1) {
-      // Remove all non-QCD partons from veto list
-      if( workEventJet[i].colType() == 0 ) {
-        workEventJet[i].statusNeg();
-        continue;
-      }
-    }
-
-    // Get the index of this particle in original event
-    int idx = workEventJet[i].daughter1();
-
-    // Start with particle idx, and afterwards track mothers
-    while (true) {
-
-      // Light jets
-      if (iType == 0) {
-
-        // Do not include if originates from heavy jet or 'other'
-        if (typeSet[1].find(idx) != typeSet[1].end() ||
-            typeSet[2].find(idx) != typeSet[2].end()) {
-          workEventJet[i].statusNeg();
-          break;
-        }
-
-        // Made it to start of event record so done
-        if (idx == 0) break;
-        // Otherwise next mother and continue
-        idx = event[idx].mother1();
-
-      // Heavy jets
-      } else if (iType == 1) {
-
-        // Only include if originates from heavy jet
-        if (typeSet[1].find(idx) != typeSet[1].end()) break;
-
-        // Made it to start of event record with no heavy jet mother,
-        // so DO NOT include particle
-        if (idx == 0) {
-          workEventJet[i].statusNeg();
-          break;
-        }
-
-        // Otherwise next mother and continue
-        idx = event[idx].mother1();
-
-      // Other jets
-      } else if (iType == 2) {
-
-        // Only include if originates from other jet
-        if (typeSet[2].find(idx) != typeSet[2].end()) break;
-
-        // Made it to start of event record with no heavy jet mother,
-        // so DO NOT include particle
-        if (idx == 0) {
-          workEventJet[i].statusNeg();
-          break;
-        }
-
-        // Otherwise next mother and continue
-        idx = event[idx].mother1();
-
-      } // if (iType)
-    } // while (true)
-  } // for (i)
-}
-
-//--------------------------------------------------------------------------
-
-// Step (2b): run jet algorithm and provide common output
-// This does nothing, because the jet algorithm is run several times
-//  in the matching algorithm.
-
-inline void JetMatchingMadgraph::runJetAlgorithm() {; }
-
-//--------------------------------------------------------------------------
-
-// Step (2c): veto decision (returning true vetoes the event)
-
-inline bool JetMatchingMadgraph::matchPartonsToJets(int iType) {
-
-  // Use different routines for light/heavy/other jets as
-  // different veto conditions and for clarity
-  if (iType == 0) {
-    // Record the jet separations here, also if matchPartonsToJetsLight
-    // returns preemptively.
-    setDJR(workEventJet);
-    set_nMEpartons(origTypeIdx[0].size(), typeIdx[0].size());
-    // Perform jet matching.
-    return (matchPartonsToJetsLight() > 0);
-  } else if (iType == 1) {
-     return (matchPartonsToJetsHeavy() > 0);
-  } else {
-     return (matchPartonsToJetsOther() > 0);
-  }
-
-}
-
-//--------------------------------------------------------------------------
-
-// Step(2c): light jets
-// Return codes are given indicating the reason for a veto.
-// Although not currently used, they are a useful debugging tool:
-//   0 = no veto
-//   1 = veto as number of jets less than number of partons
-//   2 = veto as exclusive mode and number of jets greater than
-//       number of partons
-//   3 = veto as inclusive mode and there would be an extra jet
-//       that is harder than any matched soft jet
-//   4 = veto as there is a parton which does not match a jet
-
-inline int JetMatchingMadgraph::matchPartonsToJetsLight() {
-
-  // Store things that are necessary to perform the kT-MLM veto externally.
-  workEventJetSave  = workEventJet;
-  // Done if only inputs for an external vetoing procedure should be stored.
-  if (!performVeto) return false;
-
-  // Count the number of hard partons
-  int nParton = typeIdx[0].size();
-
-  // Initialize SlowJet with current working event
-  if (!slowJet->setup(workEventJet) ) {
-    errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
-      "Light: the SlowJet algorithm failed on setup");
-    return NONE;
-  }
-  double localQcutSq = qCutSq;
-  double dOld = 0.0;
-  // Cluster in steps to find all hadronic jets at the scale qCut
-  while ( slowJet->sizeAll() - slowJet->sizeJet() > 0 ) {
-    if( slowJet->dNext() > localQcutSq ) break;
-    dOld = slowJet->dNext();
-    slowJet->doStep();
-  }
-  int nJets = slowJet->sizeJet();
-  int nClus = slowJet->sizeAll();
-
-  // Debug printout.
-  if (MATCHINGDEBUG) slowJet->list(true);
-
-  // Count of the number of hadronic jets in SlowJet accounting
-  int nCLjets = nClus - nJets;
-  // Get number of partons. Different for MLM and FxFx schemes.
-  int nRequested = (doFxFx) ? npNLO() : nParton;
-
-  // Veto event if too few hadronic jets
-  if ( nCLjets < nRequested ) return LESS_JETS;
-
-  // In exclusive mode, do not allow more hadronic jets than partons
-  if ( exclusive && !doFxFx ) {
-    if ( nCLjets > nRequested ) return MORE_JETS;
-  } else {
-
-    // For FxFx, in the non-highest multipicity, all jets need to matched to
-    // partons. For nCLjets > nRequested, this is not possible. Hence, we can
-    // veto here already.
-    if ( doFxFx && nRequested < nJetMax && nCLjets > nRequested )
-      return MORE_JETS;
-
-    // Now continue in inclusive mode.
-    // In inclusive mode, there can be more hadronic jets than partons,
-    // provided that all partons are properly matched to hadronic jets.
-    // Start by setting up the jet algorithm.
-    if (!slowJet->setup(workEventJet) ) {
-      errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
-        "Light: the SlowJet algorithm failed on setup");
-      return NONE;
-    }
-
-    // For FxFx, continue clustering as long as the jet separation is above
-    // qCut.
-    if (doFxFx) {
-      while ( slowJet->sizeAll() - slowJet->sizeJet() > 0 ) {
-        if( slowJet->dNext() > localQcutSq ) break;
-        slowJet->doStep();
-      }
-    // For MLM, cluster into hadronic jets until there are the same number as
-    // partons.
-    } else {
-      while ( slowJet->sizeAll() - slowJet->sizeJet() > nParton )
-        slowJet->doStep();
-    }
-
-    // Sort partons in pT.  Update local qCut value.
-    //  Hadronic jets are already sorted in pT.
-    localQcutSq = dOld;
-    if ( clFact >= 0. && nParton > 0 ) {
-       vector<double> partonPt;
-       for (int i = 0; i < nParton; ++i)
-         partonPt.push_back( eventProcess[typeIdx[0][i]].pT2() );
-       sort( partonPt.begin(), partonPt.end());
-       localQcutSq = max( qCutSq, partonPt[0]);
-    }
-    nJets = slowJet->sizeJet();
-    nClus = slowJet->sizeAll();
-  }
-  // Update scale if clustering factor is non-zero
-  if ( clFact != 0. ) localQcutSq *= pow2(clFact);
-
-  Event tempEvent;
-  tempEvent.init( "(tempEvent)", particleDataPtr);
-  int nPass = 0;
-  double pTminEstimate = -1.;
-  // Construct a master copy of the event containing only the
-  // hardest nParton hadronic clusters. While constructing the event,
-  // the parton type (ID_GLUON) and status (98,99) are arbitrary.
-  for (int i = nJets; i < nClus; ++i) {
-    tempEvent.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0, slowJet->p(i).px(),
-      slowJet->p(i).py(), slowJet->p(i).pz(), slowJet->p(i).e() );
-    ++nPass;
-    pTminEstimate = max( pTminEstimate, slowJet->pT(i));
-    if(nPass == nRequested) break;
-  }
-
-  int tempSize = tempEvent.size();
-  // This keeps track of which hadronic jets are matched to parton
-  vector<bool> jetAssigned;
-  jetAssigned.assign( tempSize, false);
-
-  // This keeps track of which partons are matched to which hadronic
-  // jets.
-  vector< vector<bool> > partonMatchesJet;
-  for (int i=0; i < nParton; ++i )
-    partonMatchesJet.push_back( vector<bool>(tempEvent.size(),false) );
-
-  // Begin matching.
-  // Do jet matching for FxFx.
-  // Make sure that the nPartonsNow hardest hadronic jets are matched to any
-  // of the nPartonsNow (+1) partons. This matching is done by attaching a jet
-  // from the list of unmatched hadronic jets, and appending a jet from the
-  // list of partonic jets, one at a time. The partonic jet will be clustered
-  // with the hadronic jet or the beam if the distance measure is below the
-  // cut. The hadronic jet is matched once this happens. Otherwise, another
-  // partonic jet is tried. When a hadronic jet is matched to a partonic jet,
-  // it is removed from the list of unmatched hadronic jets. This process
-  // continues until the nPartonsNow hardest hadronic jets are matched to
-  // partonic jets, or it is not possible to make a match for a hadronic jet.
-  int iNow = 0;
-  int nMatched = 0;
-  while ( doFxFx && iNow < tempSize ) {
-
-    // Check if this shower jet matches any partonic jet.
-    Event tempEventJet;
-    tempEventJet.init("(tempEventJet)", particleDataPtr);
-    for (int i=0; i < nParton; ++i ) {
-
-      //// Only assign a parton once.
-      //for (int j=0; j < tempSize; ++j )
-      //  if ( partonMatchesJet[i][j]) continue;
-
-      // Attach a single hadronic jet.
-      tempEventJet.clear();
-      tempEventJet.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0,
-        tempEvent[iNow].px(), tempEvent[iNow].py(),
-        tempEvent[iNow].pz(), tempEvent[iNow].e() );
-      // Attach the current parton.
-      Vec4 pIn = eventProcess[typeIdx[0][i]].p();
-      tempEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0,
-        pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
-
-      // Setup jet algorithm.
-      if ( !slowJet->setup(tempEventJet) ) {
-        errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
-          "Light: the SlowJet algorithm failed on setup");
-        return NONE;
-      }
-
-      // These are the conditions for the hadronic jet to match the parton
-      //  at the local qCut scale
-      if ( slowJet->iNext() == tempEventJet.size() - 1
-        && slowJet->jNext() > -1 && slowJet->dNext() < localQcutSq ) {
-        jetAssigned[iNow] = true;
-        partonMatchesJet[i][iNow] = true;
-      }
-
-    } // End loop over hard partons.
-
-    // Veto if the jet could not be assigned to any parton.
-    if ( jetAssigned[iNow] ) nMatched++;
-
-    // Continue;
-    ++iNow;
-  }
-
-  // Jet matching veto for FxFx
-  if (doFxFx) {
-    if ( nRequested <  nJetMax && nMatched != nRequested )
-      return UNMATCHED_PARTON;
-    if ( nRequested == nJetMax && nMatched <  nRequested )
-      return UNMATCHED_PARTON;
-  }
-
-  // Do jet matching for MLM.
-  // Take the list of unmatched hadronic jets and append a parton, one at
-  // a time. The parton will be clustered with the "closest" hadronic jet
-  // or the beam if the distance measure is below the cut. When a hadronic
-  // jet is matched to a parton, it is removed from the list of unmatched
-  // hadronic jets. This process continues until all hadronic jets are
-  // matched to partons or it is not possible to make a match.
-  iNow = 0;
-  while (!doFxFx && iNow < nParton ) {
-    Event tempEventJet;
-    tempEventJet.init("(tempEventJet)", particleDataPtr);
-    for (int i = 0; i < tempSize; ++i) {
-      if (jetAssigned[i]) continue;
-      Vec4 pIn = tempEvent[i].p();
-      // Append unmatched hadronic jets
-      tempEventJet.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0,
-        pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
-    }
-
-    Vec4 pIn = eventProcess[typeIdx[0][iNow]].p();
-    // Append the current parton
-    tempEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0,
-      pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
-    if ( !slowJet->setup(tempEventJet) ) {
-      errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
-        "Light: the SlowJet algorithm failed on setup");
-      return NONE;
-    }
-    // These are the conditions for the hadronic jet to match the parton
-    //  at the local qCut scale
-    if ( slowJet->iNext() == tempEventJet.size() - 1
-      && slowJet->jNext() > -1 && slowJet->dNext() < localQcutSq ) {
-      int iKnt = -1;
-      for (int i = 0; i != tempSize; ++i) {
-        if (jetAssigned[i]) continue;
-        ++iKnt;
-        // Identify the hadronic jet that matches the parton
-        if (iKnt == slowJet->jNext() ) jetAssigned[i] = true;
-      }
-    } else {
-      return UNMATCHED_PARTON;
-    }
-    ++iNow;
-  }
-
-  // Minimal eT/pT (CellJet/SlowJet) of matched light jets.
-  // Needed later for heavy jet vetos in inclusive mode.
-  // This information is not used currently.
-  if (nParton > 0 && pTminEstimate > 0) eTpTlightMin = pTminEstimate;
-  else eTpTlightMin = -1.;
-
-  // Record the jet separations.
-  setDJR(workEventJet);
-
-  // No veto
-  return NONE;
-}
-
-//--------------------------------------------------------------------------
-
-// Step(2c): heavy jets
-// Return codes are given indicating the reason for a veto.
-// Although not currently used, they are a useful debugging tool:
-//   0 = no veto as there are no extra jets present
-//   1 = veto as in exclusive mode and extra jets present
-//   2 = veto as in inclusive mode and extra jets were harder
-//       than any matched light jet
-
-inline int JetMatchingMadgraph::matchPartonsToJetsHeavy() {
-
-  // Currently, heavy jets are unmatched
-  // If there are no extra jets, then accept
-  // jetMomenta is NEVER used by MadGraph and is always empty.
-  //  This check does nothing.
-  //  Rather, if there is any heavy flavor that is harder than
-  //  what is present at the LHE level, then the event should
-  //  be vetoed.
-
-  // if (jetMomenta.empty()) return NONE;
-  // Count the number of hard partons
-  int nParton = typeIdx[1].size();
-
-  Event tempEventJet(workEventJet);
-
-  double scaleF(1.0);
-  // Rescale the heavy partons that are from the hard process to
-  //  have pT=collider energy.   Soft/collinear gluons will cluster
-  //  onto them, leaving a remnant of hard emissions.
-  for( int i=0; i<nParton; ++i) {
-    scaleF = eventProcessOrig[0].e()/workEventJet[typeIdx[1][i]].pT();
-    tempEventJet[typeIdx[1][i]].rescale5(scaleF);
-  }
-
-  if (!hjSlowJet->setup(tempEventJet) ) {
-    errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
-             "Heavy: the SlowJet algorithm failed on setup");
-    return NONE;
-  }
-
-
-  while ( hjSlowJet->sizeAll() - hjSlowJet->sizeJet() > 0 ) {
-    if( hjSlowJet->dNext() > qCutSq ) break;
-    hjSlowJet->doStep();
-  }
-
-  int nCLjets(0);
-  // Count the number of clusters with pT>qCut.  This includes the
-  //  original hard partons plus any hard emissions.
-  for(int idx=0 ; idx< hjSlowJet->sizeAll(); ++idx) {
-    if( hjSlowJet->pT(idx) > sqrt(qCutSq) ) nCLjets++;
-  }
-
-  // Debug printout.
-  if (MATCHINGDEBUG) hjSlowJet->list(true);
-
-  // Count of the number of hadronic jets in SlowJet accounting
-  //  int nCLjets = nClus - nJets;
-  // Get number of partons. Different for MLM and FxFx schemes.
-  int nRequested = nParton;
-
-  // Veto event if too few hadronic jets
-  if ( nCLjets < nRequested ) {
-    if (MATCHINGDEBUG) cout << "veto : hvy  LESS_JETS " << endl;
-    if (MATCHINGDEBUG) cout << "nCLjets = " << nCLjets << "; nRequest = "
-      << nRequested << endl;
-    return LESS_JETS;
-  }
-
-  // In exclusive mode, do not allow more hadronic jets than partons
-  if ( exclusive ) {
-    if ( nCLjets > nRequested ) {
-      if (MATCHINGDEBUG) cout << "veto : excl hvy  MORE_JETS " << endl;
-      return MORE_JETS;
-    }
-  }
-
-  // No extra jets were present so no veto
-  return NONE;
-}
-
-//--------------------------------------------------------------------------
-
-// Step(2c): other jets
-// Return codes are given indicating the reason for a veto.
-// Although not currently used, they are a useful debugging tool:
-//   0 = no veto as there are no extra jets present
-//   1 = veto as in exclusive mode and extra jets present
-//   2 = veto as in inclusive mode and extra jets were harder
-//       than any matched light jet
-
-inline int JetMatchingMadgraph::matchPartonsToJetsOther() {
-
-  // Currently, heavy jets are unmatched
-  // If there are no extra jets, then accept
-  // jetMomenta is NEVER used by MadGraph and is always empty.
-  //  This check does nothing.
-  //  Rather, if there is any heavy flavor that is harder than
-  //  what is present at the LHE level, then the event should
-  //  be vetoed.
-
-  // if (jetMomenta.empty()) return NONE;
-  // Count the number of hard partons
-  int nParton = typeIdx[2].size();
-
-  Event tempEventJet(workEventJet);
-
-  double scaleF(1.0);
-  // Rescale the heavy partons that are from the hard process to
-  //  have pT=collider energy.   Soft/collinear gluons will cluster
-  //  onto them, leaving a remnant of hard emissions.
-  for( int i=0; i<nParton; ++i) {
-    scaleF = eventProcessOrig[0].e()/workEventJet[typeIdx[2][i]].pT();
-    tempEventJet[typeIdx[2][i]].rescale5(scaleF);
-  }
-
-  if (!hjSlowJet->setup(tempEventJet) ) {
-    errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
-             "Heavy: the SlowJet algorithm failed on setup");
-    return NONE;
-  }
-
-
-  while ( hjSlowJet->sizeAll() - hjSlowJet->sizeJet() > 0 ) {
-    if( hjSlowJet->dNext() > qCutSq ) break;
-    hjSlowJet->doStep();
-  }
-
-  int nCLjets(0);
-  // Count the number of clusters with pT>qCut.  This includes the
-  //  original hard partons plus any hard emissions.
-  for(int idx=0 ; idx< hjSlowJet->sizeAll(); ++idx) {
-    if( hjSlowJet->pT(idx) > sqrt(qCutSq) ) nCLjets++;
-  }
-
-  // Debug printout.
-  if (MATCHINGDEBUG) hjSlowJet->list(true);
-
-  // Count of the number of hadronic jets in SlowJet accounting
-  //  int nCLjets = nClus - nJets;
-  // Get number of partons. Different for MLM and FxFx schemes.
-  int nRequested = nParton;
-
-  // Veto event if too few hadronic jets
-  if ( nCLjets < nRequested ) {
-    if (MATCHINGDEBUG) cout << "veto : other LESS_JETS " << endl;
-    if (MATCHINGDEBUG) cout << "nCLjets = " << nCLjets << "; nRequest = "
-      << nRequested << endl;
-    return LESS_JETS;
-  }
-
-  // In exclusive mode, do not allow more hadronic jets than partons
-  if ( exclusive ) {
-    if ( nCLjets > nRequested ) {
-      if (MATCHINGDEBUG) cout << "veto : excl other MORE_JETS" << endl;
-      return MORE_JETS;
-    }
-  }
-
-  // No extra jets were present so no veto
-  return NONE;
-}
-
-//==========================================================================
 
 } // end namespace Pythia8
 
 
diff -rupN pythia8306_original/src/Event.cc pythia8306_patched/src/Event.cc
--- pythia8306_original/src/Event.cc	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/src/Event.cc	2023-06-27 02:09:11.956196135 +0200
@@ -706,15 +706,15 @@ void Event::remove(int iFirst, int iLast
 // Print an event.
 
 void Event::list(bool showScaleAndVertex, bool showMothersAndDaughters,
-  int precision) const {
+  int precision, ostream& os) const {
 
   // Header.
-  cout << "\n --------  PYTHIA Event Listing  " << headerList << "----------"
+  os << "\n --------  PYTHIA Event Listing  " << headerList << "----------"
        << "-------------------------------------------------\n \n    no    "
        << "     id  name            status     mothers   daughters     colou"
        << "rs      p_x        p_y        p_z         e          m \n";
   if (showScaleAndVertex)
-    cout << "                                    scale         pol          "
+    os << "                                    scale         pol          "
          << "                   xProd      yProd      zProd      tProd      "
          << " tau\n";
 
@@ -729,7 +729,7 @@ void Event::list(bool showScaleAndVertex
     const Particle& pt = entry[i];
 
     // Basic line for a particle, always printed.
-    cout << setw(6) << i << setw(11) << pt.id() << "  " << left
+    os << setw(6) << i << setw(11) << pt.id() << "  " << left
          << setw(18) << pt.nameWithStatus(18) << right << setw(4)
          << pt.status() << setw(6) << pt.mother1() << setw(6)
          << pt.mother2() << setw(6) << pt.daughter1() << setw(6)
@@ -741,7 +741,7 @@ void Event::list(bool showScaleAndVertex
 
     // Optional extra line for scale value, polarization and production vertex.
     if (showScaleAndVertex)
-      cout << "                              " << setw(8+prec) << pt.scale()
+      os << "                              " << setw(8+prec) << pt.scale()
            << " " << fixed << setprecision(prec) << setw(8+prec) << pt.pol()
            << "                        " << scientific << setprecision(prec)
            << setw(8+prec) << pt.xProd() << setw(8+prec) << pt.yProd()
@@ -751,29 +751,29 @@ void Event::list(bool showScaleAndVertex
     // Optional extra line, giving a complete list of mothers and daughters.
     if (showMothersAndDaughters) {
       int linefill = 2;
-      cout << "                mothers:";
+      os << "                mothers:";
       vector<int> allMothers = pt.motherList();
       for (int j = 0; j < int(allMothers.size()); ++j) {
-        cout << " " <<  allMothers[j];
+        os << " " <<  allMothers[j];
         if (++linefill == IPERLINE) {
-          cout << "\n                ";
+          os << "\n                ";
           linefill = 0;
         }
       }
-      cout << ";   daughters:";
+      os << ";   daughters:";
       vector<int> allDaughters = pt.daughterList();
       for (int j = 0; j < int(allDaughters.size()); ++j) {
-        cout << " " <<  allDaughters[j];
+        os << " " <<  allDaughters[j];
         if (++linefill == IPERLINE) {
-          cout << "\n                ";
+          os << "\n                ";
           linefill = 0;
         }
       }
-      if (linefill !=0) cout << "\n";
+      if (linefill !=0) os << "\n";
     }
 
     // Extra blank separation line when each particle spans more than one line.
-    if (showScaleAndVertex || showMothersAndDaughters) cout << "\n";
+    if (showScaleAndVertex || showMothersAndDaughters) os << "\n";
 
     // Statistics on momentum and charge.
     if (entry[i].status() > 0) {
@@ -783,7 +783,7 @@ void Event::list(bool showScaleAndVertex
   }
 
   // Line with sum charge, momentum, energy and invariant mass.
-  cout << fixed << setprecision(3) << "                                   "
+  os << fixed << setprecision(3) << "                                   "
        << "Charge sum:" << setw(7) << chargeSum << "           Momentum sum:"
        << ( (useFixed) ? fixed : scientific ) << setprecision(prec)
        << setw(8+prec) << pSum.px() << setw(8+prec) << pSum.py()
@@ -791,7 +791,7 @@ void Event::list(bool showScaleAndVertex
        << setw(8+prec) << pSum.mCalc() << "\n";
 
   // Listing finished.
-  cout << "\n --------  End PYTHIA Event Listing  ----------------------------"
+  os << "\n --------  End PYTHIA Event Listing  ----------------------------"
        << "-------------------------------------------------------------------"
        << endl;
 }
diff -rupN pythia8306_original/src/GeneratorInput.cc pythia8306_patched/src/GeneratorInput.cc
--- pythia8306_original/src/GeneratorInput.cc	1970-01-01 01:00:00.000000000 +0100
+++ pythia8306_patched/src/GeneratorInput.cc	2023-06-27 02:09:11.956196135 +0200
@@ -0,0 +1,1048 @@
+#include "Pythia8Plugins/GeneratorInput.h"
+
+// GAMBIT: We moved the below definitions from GeneratorInput.h
+//         to this source file to allow easy BOSSing
+
+
+namespace Pythia8 {
+
+//==========================================================================
+
+// Main implementation of AlpgenPar class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+//--------------------------------------------------------------------------
+
+// Constants: could be changed here if desired, but normally should not.
+// These are of technical nature, as described for each.
+
+// A zero threshold value for double comparisons.
+const double AlpgenPar::ZEROTHRESHOLD = 1e-10;
+
+//--------------------------------------------------------------------------
+
+// Warn if e/pT imbalance greater than these values
+// Parse an incoming Alpgen parameter file string
+
+inline bool AlpgenPar::parse(const string paramStr) {
+
+  // Read par file in blocks:
+  //   0 - process information
+  //   1 - run parameters
+  //   2 - cross sections
+  int block = 0;
+
+  // Loop over incoming lines
+  stringstream paramStream(paramStr);
+  string line;
+  while (getline(paramStream, line)) {
+
+    // Change to 'run parameters' block
+    if        (line.find("run parameters") != string::npos) {
+      block = 1;
+
+    // End of 'run parameters' block
+    } else if (line.find("end parameters") != string::npos) {
+      block = 2;
+
+    // Do not extract anything from block 0 so far
+    } else if (block == 0) {
+
+    // Block 1 or 2: extract parameters
+    } else {
+      extractRunParam(line);
+
+    }
+  } // while (getline(paramStream, line))
+
+  return true;
+}
+
+//--------------------------------------------------------------------------
+
+// Parse an incoming parameter line
+
+inline void AlpgenPar::extractRunParam(string line) {
+
+  // Extract information to the right of the final '!' character
+  size_t idx = line.rfind("!");
+  if (idx == string::npos) return;
+  string paramName = trim(line.substr(idx + 1));
+  string paramVal  = trim(line.substr(0, idx));
+  istringstream iss(paramVal);
+
+  // Special case: 'hard process code' - single integer input
+  double val;
+  if (paramName == "hard process code") {
+    iss >> val;
+    warnParamOverwrite("hpc", val);
+    params["hpc"] = val;
+
+  // Special case: 'Crosssection +- error (pb)' - two double values
+  } else if (paramName.find("Crosssection") == 0) {
+    double xerrup;
+    iss >> val >> xerrup;
+    warnParamOverwrite("xsecup", val);
+    warnParamOverwrite("xerrup", val);
+    params["xsecup"] = val;
+    params["xerrup"] = xerrup;
+
+  // Special case: 'unwtd events, lum (pb-1)' - integer and double values
+  } else if (paramName.find("unwtd events") == 0) {
+    int nevent;
+    iss >> nevent >> val;
+    warnParamOverwrite("nevent", val);
+    warnParamOverwrite("lum", val);
+    params["nevent"] = nevent;
+    params["lum"]    = val;
+
+  // Special case: 'mc,mb,...' - split on ',' for name and ' ' for values
+  } else if (paramName.find(",") != string::npos) {
+
+    // Simple tokeniser
+    string        paramNameNow;
+    istringstream issName(paramName);
+    while (getline(issName, paramNameNow, ',')) {
+      iss >> val;
+      warnParamOverwrite(paramNameNow, val);
+      params[paramNameNow] = val;
+    }
+
+  // Default case: assume integer and double on the left
+  } else {
+    int paramIdx;
+    iss >> paramIdx >> val;
+    warnParamOverwrite(paramName, val);
+    params[paramName] = val;
+  }
+}
+
+//--------------------------------------------------------------------------
+
+// Print parameters read from the '.par' file
+
+inline void AlpgenPar::printParams() {
+
+  // Loop over all stored parameters and print
+  cout << fixed << setprecision(3) << endl
+       << " *-------  Alpgen parameters  -------*" << endl;
+  for (map < string, double >::iterator it = params.begin();
+       it != params.end(); ++it)
+    cout << " |  " << left << setw(13) << it->first
+         << "  |  " << right << setw(13) << it->second
+         << "  |" << endl;
+  cout << " *-----------------------------------*" << endl;
+}
+
+//--------------------------------------------------------------------------
+
+// Warn if a parameter is going to be overwriten
+
+inline void AlpgenPar::warnParamOverwrite(const string &paramIn, double val) {
+
+  // Check if present and if new value is different
+  if (haveParam(paramIn) &&
+      abs(getParam(paramIn) - val) > ZEROTHRESHOLD) {
+    cout << "Warning in LHAupAlpgen::warnParamOverwrite:"
+         << " overwriting existing parameter" << paramIn << endl;
+  }
+}
+
+//--------------------------------------------------------------------------
+
+// Simple string trimmer
+
+inline string AlpgenPar::trim(string s) {
+
+  // Remove whitespace in incoming string
+  size_t i;
+  if ((i = s.find_last_not_of(" \t\r\n")) != string::npos)
+    s = s.substr(0, i + 1);
+  if ((i = s.find_first_not_of(" \t\r\n")) != string::npos)
+    s = s.substr(i);
+  return s;
+}
+
+//==========================================================================
+
+// Main implementation of LHAupAlpgen class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+// ----------------------------------------------------------------------
+
+// Constants: could be changed here if desired, but normally should not.
+// These are of technical nature, as described for each.
+
+// Debug flag to print all particles in each event.
+const bool LHAupAlpgen::LHADEBUG        = false;
+
+// Debug flag to print particles when an e/p imbalance is found.
+const bool LHAupAlpgen::LHADEBUGRESCALE = false;
+
+// A zero threshold value for double comparisons.
+const double LHAupAlpgen::ZEROTHRESHOLD   = 1e-10;
+
+// Warn if e/pT imbalance greater than these values
+const double LHAupAlpgen::EWARNTHRESHOLD  = 3e-3;
+const double LHAupAlpgen::PTWARNTHRESHOLD = 1e-3;
+
+// If incoming e/pZ is 0, it is reset to this value
+const double LHAupAlpgen::INCOMINGMIN     = 1e-3;
+
+// ----------------------------------------------------------------------
+
+// Constructor. Opens parameter file and parses then opens event file.
+
+LHAupAlpgen::LHAupAlpgen(const char* baseFNin)
+  : baseFN(baseFNin), alpgenPar(), isUnw(NULL) {
+
+  // Read in '_unw.par' file to get parameters
+  ifstream  ifsPar;
+  istream*  isPar = NULL;
+
+  // Try gzip file first then normal file afterwards
+#ifdef GZIP
+  parFN = baseFN + "_unw.par.gz";
+  isPar = openFile(parFN.c_str(), ifsPar);
+  if (!ifsPar.is_open()) closeFile(isPar, ifsPar);
+#endif
+  if (isPar == NULL) {
+    parFN = baseFN + "_unw.par";
+    isPar = openFile(parFN.c_str(), ifsPar);
+    if (!ifsPar.is_open()) {
+      cout << "Error in LHAupAlpgen::LHAupAlpgen: "
+           << "cannot open parameter file " << parFN << endl;
+      closeFile(isPar, ifsPar);
+      return;
+    }
+  }
+
+  // Read entire contents into string and close file
+  string paramStr((std::istreambuf_iterator<char>(isPar->rdbuf())),
+                   std::istreambuf_iterator<char>());
+
+  // Make sure we reached EOF and not other error
+  if (ifsPar.bad()) {
+    cout << "Error in LHAupAlpgen::LHAupAlpgen: "
+         << "cannot read parameter file " << parFN << endl;
+    return;
+  }
+  closeFile(isPar, ifsPar);
+
+  // Parse file and set LHEF header
+  alpgenPar.parse(paramStr);
+  setInfoHeader("AlpgenPar", paramStr);
+
+  // Open '.unw' events file (with possible gzip support)
+#ifdef GZIP
+  unwFN = baseFN + ".unw.gz";
+  isUnw = openFile(unwFN.c_str(), ifsUnw);
+  if (!ifsUnw.is_open()) closeFile(isUnw, ifsUnw);
+#endif
+  if (isUnw == NULL) {
+    unwFN = baseFN + ".unw";
+    isUnw = openFile(unwFN.c_str(), ifsUnw);
+    if (!ifsUnw.is_open()) {
+      cout << "Error in LHAupAlpgen::LHAupAlpgen: "
+           << "cannot open event file " << unwFN << endl;
+      closeFile(isUnw, ifsUnw);
+    }
+  }
+}
+
+// ----------------------------------------------------------------------
+
+// setInit is a virtual method that must be finalised here.
+// Sets up beams, strategy and processes.
+
+inline bool LHAupAlpgen::setInit() {
+
+  // Check that all required parameters are present
+  if (!alpgenPar.haveParam("ih2") || !alpgenPar.haveParam("ebeam")  ||
+      !alpgenPar.haveParam("hpc") || !alpgenPar.haveParam("xsecup") ||
+      !alpgenPar.haveParam("xerrup")) {
+    cout << "Error in LHAupAlpgen::setInit: "
+         << "missing input parameters" << endl;
+    return false;
+  }
+
+  // Beam IDs
+  int ih2 = alpgenPar.getParamAsInt("ih2");
+  int idbmupA = 2212;
+  int idbmupB = (ih2 == 1) ? 2212 : -2212;
+
+  // Beam energies
+  double ebeam = alpgenPar.getParam("ebeam");
+  ebmupA = ebeam;
+  ebmupB = ebmupA;
+
+  // PDF group and set (at the moment not set)
+  int pdfgupA = 0, pdfsupA = 0;
+  int pdfgupB = 0, pdfsupB = 0;
+
+  // Strategy is for unweighted events and xmaxup not important
+  int    idwtup = 3;
+  double xmaxup = 0.;
+
+  // Get hard process code
+  lprup = alpgenPar.getParamAsInt("hpc");
+
+  // Check for unsupported processes
+  if (lprup == 7 || lprup == 8 || lprup == 13) {
+    cout << "Error in LHAupAlpgen::setInit: "
+         << "process not implemented" << endl;
+    return false;
+  }
+
+  // Depending on the process code, get heavy flavour information:
+  //    6 = QQbar           + jets
+  //    7 = QQbar + Q'Qbar' + jets
+  //    8 = QQbar + Higgs   + jets
+  //   16 = QQbar + gamma   + jets
+  if (lprup == 6 || lprup == 7 || lprup == 8 || lprup == 16) {
+    if (!alpgenPar.haveParam("ihvy")) {
+      cout << "Error in LHAupAlpgen::setInit: "
+           << "heavy flavour information not present" << endl;
+      return false;
+    }
+    ihvy1 = alpgenPar.getParamAsInt("ihvy");
+
+  } else ihvy1 = -1;
+  if (lprup == 7) {
+    if (!alpgenPar.haveParam("ihvy2")) {
+      cout << "Error in LHAupAlpgen::setInit: "
+           << "heavy flavour information not present" << endl;
+      return false;
+    }
+    ihvy2 = alpgenPar.getParamAsInt("ihvy2");
+  } else ihvy2 = -1;
+  // For single top (process 13), get b mass to set incoming
+  mb = -1.;
+  if (lprup == 13) {
+    if (!alpgenPar.haveParam("mb")) {
+      cout << "Error in LHAupAlpgen::setInit: "
+           << "heavy flavour information not present" << endl;
+      return false;
+    }
+    mb = alpgenPar.getParam("mb");
+  }
+
+  // Set the beams
+  setBeamA(idbmupA, ebmupA, pdfgupA, pdfsupA);
+  setBeamB(idbmupB, ebmupB, pdfgupB, pdfsupB);
+  setStrategy(idwtup);
+
+  // Add the process
+  double xsecup = alpgenPar.getParam("xsecup");
+  double xerrup = alpgenPar.getParam("xerrup");
+  addProcess(lprup, xsecup, xerrup, xmaxup);
+  xSecSumSave = xsecup;
+  xErrSumSave = xerrup;
+
+  // All okay
+  return true;
+}
+
+// ----------------------------------------------------------------------
+
+// setEvent is a virtual method that must be finalised here.
+// Read in an event from the 'unw' file and setup.
+
+inline bool LHAupAlpgen::setEvent(int) {
+
+  // Read in the first line of the event
+  int    nEvent, iProc, nParton;
+  double Swgt, Sq;
+  string line;
+  if (!getline(*isUnw, line)) {
+    // Read was bad
+    if (ifsUnw.bad()) {
+      cout << "Error in LHAupAlpgen::setEvent: "
+           << "could not read events from file" << endl;
+      return false;
+    }
+    // End of file reached
+    cout << "Error in LHAupAlpgen::setEvent: "
+         << "end of file reached" << endl;
+    return false;
+  }
+  istringstream iss1(line);
+  iss1 >> nEvent >> iProc >> nParton >> Swgt >> Sq;
+
+  // Set the process details (ignore alphaQED and alphaQCD parameters)
+  double wgtT = Swgt, scaleT = Sq;
+  setProcess(lprup, wgtT, scaleT);
+
+  // Incoming flavour and x information for later
+  int    id1T, id2T;
+  double x1T, x2T;
+  // Temporary storage for read in parton information
+  int    idT, statusT, mother1T, mother2T, col1T, col2T;
+  double pxT, pyT, pzT, eT, mT;
+  // Leave tau and spin as default values
+  double tauT = 0., spinT = 9.;
+
+  // Store particles locally at first so that resonances can be added
+  myParticles.clear();
+
+  // Now read in partons
+  for (int i = 0; i < nParton; i++) {
+    // Get the next line
+    if (!getline(*isUnw, line)) {
+      cout << "Error in LHAupAlpgen::setEvent: "
+           << "could not read events from file" << endl;
+      return false;
+    }
+    istringstream iss2(line);
+
+    // Incoming (flavour, colour, anticolour, pz)
+    if (i < 2) {
+      // Note that mothers will be set automatically by Pythia, and LHA
+      // status -1 is for an incoming parton
+      iss2 >> idT >> col1T >> col2T >> pzT;
+      statusT  = -1;
+      mother1T = mother2T = 0;
+      pxT = pyT = mT = 0.;
+      eT  = abs(pzT);
+
+      // Adjust when zero pz/e
+      if (pzT == 0.) {
+        pzT = (i == 0) ? INCOMINGMIN : -INCOMINGMIN;
+        eT  = INCOMINGMIN;
+      }
+
+    // Outgoing (flavour, colour, anticolour, px, py, pz, mass)
+    } else {
+      // Note that mothers 1 and 2 corresport to the incoming partons,
+      // as set above, and LHA status +1 is for outgoing final state
+      iss2 >> idT >> col1T >> col2T >> pxT >> pyT >> pzT >> mT;
+      statusT  = 1;
+      mother1T = 1;
+      mother2T = 2;
+      eT = sqrt(max(0., pxT*pxT + pyT*pyT + pzT*pzT + mT*mT));
+    }
+
+    // Add particle
+    myParticles.push_back(LHAParticle(
+        idT, statusT, mother1T, mother2T, col1T, col2T,
+        pxT, pyT, pzT, eT, mT, tauT, spinT,-1.));
+  }
+
+  // Add resonances if required
+  if (!addResonances()) return false;
+
+  // Rescale momenta if required (must be done after full event
+  // reconstruction in addResonances)
+  if (!rescaleMomenta()) return false;
+
+  // Pass particles on to Pythia
+  for (size_t i = 0; i < myParticles.size(); i++)
+    addParticle(myParticles[i]);
+
+  // Set incoming flavour/x information and done
+  id1T = myParticles[0].idPart;
+  x1T  = myParticles[0].ePart / ebmupA;
+  id2T = myParticles[1].idPart;
+  x2T  = myParticles[1].ePart / ebmupA;
+  setIdX(id1T, id2T, x1T, x2T);
+  setPdf(id1T, id2T, x1T, x2T, 0., 0., 0., false);
+  return true;
+}
+
+// ----------------------------------------------------------------------
+
+// Print list of particles; mainly intended for debugging
+
+inline void LHAupAlpgen::printParticles() {
+
+  cout << endl << "---- LHAupAlpgen particle listing begin ----" << endl;
+  cout << scientific << setprecision(6);
+  for (int i = 0; i < int(myParticles.size()); i++) {
+    cout << setw(5)  << i
+         << setw(5)  << myParticles[i].idPart
+         << setw(5)  << myParticles[i].statusPart
+         << setw(15) << myParticles[i].pxPart
+         << setw(15) << myParticles[i].pyPart
+         << setw(15) << myParticles[i].pzPart
+         << setw(15) << myParticles[i].ePart
+         << setw(15) << myParticles[i].mPart
+         << setw(5)  << myParticles[i].mother1Part - 1
+         << setw(5)  << myParticles[i].mother2Part - 1
+         << setw(5)  << myParticles[i].col1Part
+         << setw(5)  << myParticles[i].col2Part
+         << endl;
+  }
+  cout << "----  LHAupAlpgen particle listing end  ----" << endl;
+}
+
+// ----------------------------------------------------------------------
+
+// Routine to add resonances to an incoming event based on the
+// hard process code (now stored in lprup).
+
+inline bool LHAupAlpgen::addResonances() {
+
+  // Temporary storage for resonance information
+  int    idT, statusT, mother1T, mother2T, col1T, col2T;
+  double pxT, pyT, pzT, eT, mT;
+  // Leave tau and spin as default values
+  double tauT = 0., spinT = 9.;
+
+  // Alpgen process dependent parts. Processes:
+  //    1 = W        + QQbar         + jets
+  //    2 = Z/gamma* + QQbar         + jets
+  //    3 = W                        + jets
+  //    4 = Z/gamma*                 + jets
+  //   10 = W        + c             + jets
+  //   14 = W        + gamma         + jets
+  //   15 = W        + QQbar + gamma + jets
+  // When QQbar = ttbar, tops are not decayed in these processes.
+  // Explicitly reconstruct W/Z resonances; assumption is that the
+  // decay products are the last two particles.
+  if (lprup <= 4 || lprup == 10 || lprup == 14 || lprup == 15) {
+    // Decay products are the last two entries
+    int i1 = myParticles.size() - 1, i2 = i1 - 1;
+
+    // Follow 'alplib/alpsho.f' procedure to get ID
+    if (myParticles[i1].idPart + myParticles[i2].idPart == 0)
+      idT = 0;
+    else
+      idT = - (myParticles[i1].idPart % 2) - (myParticles[i2].idPart % 2);
+    idT = (idT > 0) ? 24 : (idT < 0) ? -24 : 23;
+
+    // Check that we get the expected resonance type; Z/gamma*
+    if (lprup == 2 || lprup == 4) {
+      if (idT != 23) {
+        cout << "Error in "
+             << "LHAupAlpgen::addResonances: wrong resonance type in event"
+             << endl;
+        return false;
+      }
+
+    // W's
+    } else {
+      if (abs(idT) != 24) {
+        cout << "Error in "
+             << "LHAupAlpgen::addResonances: wrong resonance type in event"
+             << endl;
+        return false;
+      }
+    }
+
+    // Remaining input
+    statusT  = 2;
+    mother1T = 1;
+    mother2T = 2;
+    col1T = col2T = 0;
+    pxT = myParticles[i1].pxPart + myParticles[i2].pxPart;
+    pyT = myParticles[i1].pyPart + myParticles[i2].pyPart;
+    pzT = myParticles[i1].pzPart + myParticles[i2].pzPart;
+    eT  = myParticles[i1].ePart  + myParticles[i2].ePart;
+    mT  = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
+    myParticles.push_back(LHAParticle(
+        idT, statusT, mother1T, mother2T, col1T, col2T,
+        pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
+
+    // Update decay product mothers (note array size as if from 1)
+    myParticles[i1].mother1Part = myParticles[i2].mother1Part =
+        myParticles.size();
+    myParticles[i1].mother2Part = myParticles[i2].mother2Part = 0;
+
+  // Processes:
+  //    5 = nW + mZ + j gamma + lH + jets
+  //    6 = QQbar         + jets    (QQbar = ttbar)
+  //    8 = QQbar + Higgs + jets    (QQbar = ttbar)
+  //   13 = top   + q               (topprc = 1)
+  //   13 = top   + b               (topprc = 2)
+  //   13 = top   + W     + jets    (topprc = 3)
+  //   13 = top   + W     + b       (topprc = 4)
+  //   16 = QQbar + gamma + jets    (QQbar = ttbar)
+  //
+  // When tops are present, they are decayed to Wb (both the W and b
+  // are not given), with this W also decaying (decay products given).
+  // The top is marked intermediate, the (intermediate) W is
+  // reconstructed from its decay products, and the decay product mothers
+  // updated. The final-state b is reconstructed from (top - W).
+  //
+  // W/Z resonances are given, as well as their decay products. The
+  // W/Z is marked intermediate, and the decay product mothers updated.
+  //
+  // It is always assumed that decay products are at the end.
+  // For processes 5 and 13, it is also assumed that the decay products
+  // are in the same order as the resonances.
+  // For processes 6, 8 and 16, the possibility of the decay products
+  // being out-of-order is also taken into account.
+  } else if ( ((lprup == 6 || lprup == 8 || lprup == 16) && ihvy1 == 6) ||
+              lprup == 5 || lprup == 13) {
+
+    // Go backwards through the particles looking for W/Z/top
+    int idx = myParticles.size() - 1;
+    for (int i = myParticles.size() - 1; i > -1; i--) {
+
+      // W or Z
+      if (myParticles[i].idPart == 23 ||
+          abs(myParticles[i].idPart) == 24) {
+
+        // Check that decay products and resonance match up
+        int flav;
+        if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
+          flav = 0;
+        else
+          flav = - (myParticles[idx].idPart % 2)
+                 - (myParticles[idx - 1].idPart % 2);
+        flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
+        if (flav != myParticles[i].idPart) {
+          if (infoPtr)
+            infoPtr->errorMsg("Error in LHAupAlpgen::addResonance: "
+                "resonance does not match decay products");
+          return false;
+        }
+
+        // Update status/mothers
+        myParticles[i].statusPart      = 2;
+        myParticles[idx  ].mother1Part = i + 1;
+        myParticles[idx--].mother2Part = 0;
+        myParticles[idx  ].mother1Part = i + 1;
+        myParticles[idx--].mother2Part = 0;
+
+      // Top
+      } else if (abs(myParticles[i].idPart) == 6) {
+
+        // Check that decay products and resonance match up
+        int flav;
+        if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
+          flav = 0;
+        else
+          flav = - (myParticles[idx].idPart % 2)
+                 - (myParticles[idx - 1].idPart % 2);
+        flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
+
+        bool outOfOrder = false, wrongFlavour = false;;
+        if ( abs(flav) != 24 ||
+             (flav ==  24 && myParticles[i].idPart !=  6) ||
+             (flav == -24 && myParticles[i].idPart != -6) ) {
+
+          // Processes 5 and 13, order should always be correct
+          if (lprup == 5 || lprup == 13) {
+            wrongFlavour = true;
+
+          // Processes 6, 8 and 16, can have out of order decay products
+          } else {
+
+            // Go back two decay products and retry
+            idx -= 2;
+            if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
+              flav = 0;
+            else
+              flav = - (myParticles[idx].idPart % 2)
+                     - (myParticles[idx - 1].idPart % 2);
+            flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
+
+            // If still the wrong flavour then error
+            if ( abs(flav) != 24 ||
+                 (flav ==  24 && myParticles[i].idPart !=  6) ||
+                 (flav == -24 && myParticles[i].idPart != -6) )
+              wrongFlavour = true;
+            else outOfOrder = true;
+          }
+
+          // Error if wrong flavour
+          if (wrongFlavour) {
+            if (infoPtr)
+              infoPtr->errorMsg("Error in LHAupAlpgen::addResonance: "
+                  "resonance does not match decay products");
+            return false;
+          }
+        }
+
+        // Mark t/tbar as now intermediate
+        myParticles[i].statusPart = 2;
+
+        // New intermediate W+/W-
+        idT      = flav;
+        statusT  = 2;
+        mother1T = i + 1;
+        mother2T = 0;
+        col1T = col2T = 0;
+        pxT = myParticles[idx].pxPart + myParticles[idx - 1].pxPart;
+        pyT = myParticles[idx].pyPart + myParticles[idx - 1].pyPart;
+        pzT = myParticles[idx].pzPart + myParticles[idx - 1].pzPart;
+        eT  = myParticles[idx].ePart  + myParticles[idx - 1].ePart;
+        mT  = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
+        myParticles.push_back(LHAParticle(
+            idT, statusT, mother1T, mother2T, col1T, col2T,
+            pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
+
+        // Update the decay product mothers
+        myParticles[idx  ].mother1Part = myParticles.size();
+        myParticles[idx--].mother2Part = 0;
+        myParticles[idx  ].mother1Part = myParticles.size();
+        myParticles[idx--].mother2Part = 0;
+
+        // New final-state b/bbar
+        idT     = (flav == 24) ? 5 : -5;
+        statusT = 1;
+        // Colour from top
+        col1T   = myParticles[i].col1Part;
+        col2T   = myParticles[i].col2Part;
+        // Momentum from (t/tbar - W+/W-)
+        pxT     = myParticles[i].pxPart - myParticles.back().pxPart;
+        pyT     = myParticles[i].pyPart - myParticles.back().pyPart;
+        pzT     = myParticles[i].pzPart - myParticles.back().pzPart;
+        eT      = myParticles[i].ePart  - myParticles.back().ePart;
+        mT      = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
+        myParticles.push_back(LHAParticle(
+            idT, statusT, mother1T, mother2T, col1T, col2T,
+            pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
+
+        // If decay products were out of order, reset idx to point
+        // at correct decay products
+        if (outOfOrder) idx += 4;
+
+      } // if (abs(myParticles[i].idPart) == 6)
+    } // for (i)
+
+
+  // Processes:
+  //    7 = QQbar + Q'Qbar' + jets (tops are not decayed)
+  //    9 =                   jets
+  //   11 = gamma           + jets
+  //   12 = Higgs           + jets
+  } else if (lprup == 7 || lprup == 9 || lprup == 11 || lprup == 12) {
+    // Nothing to do for these processes
+  }
+
+  // For single top, set incoming b mass if necessary
+  if (lprup == 13) for (int i = 0; i < 2; i++)
+    if (abs(myParticles[i].idPart) == 5) {
+      myParticles[i].mPart = mb;
+      myParticles[i].ePart = sqrt(pow2(myParticles[i].pzPart) + pow2(mb));
+    }
+
+  // Debug output and done.
+  if (LHADEBUG) printParticles();
+  return true;
+
+}
+
+// ----------------------------------------------------------------------
+
+// Routine to rescale momenta to remove any imbalances. The routine
+// assumes that any imbalances are due to decimal output/rounding
+// effects, and are therefore small.
+//
+// First any px/py imbalances are fixed by adjusting all outgoing
+// particles px/py and also updating their energy so mass is fixed.
+// Because incoming pT is zero, changes should be limited to ~0.001.
+//
+// Second, any pz/e imbalances are fixed by scaling the incoming beams
+// (again, no changes to masses required). Because incoming pz/e is not
+// zero, effects can be slightly larger ~0.002/0.003.
+
+inline bool LHAupAlpgen::rescaleMomenta() {
+
+  // Total momenta in/out
+  int  nOut = 0;
+  Vec4 pIn, pOut;
+  for (int i = 0; i < int(myParticles.size()); i++) {
+    Vec4 pNow = Vec4(myParticles[i].pxPart, myParticles[i].pyPart,
+                     myParticles[i].pzPart, myParticles[i].ePart);
+    if (i < 2) pIn += pNow;
+    else if (myParticles[i].statusPart == 1) {
+      nOut++;
+      pOut += pNow;
+    }
+  }
+
+  // pT out to match pT in. Split any imbalances over all outgoing
+  // particles, and scale energies also to keep m^2 fixed.
+  if (abs(pOut.pT() - pIn.pT()) > ZEROTHRESHOLD) {
+    // Differences in px/py
+    double pxDiff = (pOut.px() - pIn.px()) / nOut,
+           pyDiff = (pOut.py() - pIn.py()) / nOut;
+
+    // Warn if resulting changes above warning threshold
+    if (pxDiff > PTWARNTHRESHOLD || pyDiff > PTWARNTHRESHOLD) {
+      cout << "Warning in LHAupAlpgen::setEvent: "
+           << "large pT imbalance in incoming event" << endl;
+
+      // Debug printout
+      if (LHADEBUGRESCALE) {
+        printParticles();
+        cout << "pxDiff = " << pxDiff << ", pyDiff = " << pyDiff << endl;
+      }
+    }
+
+    // Adjust all final-state outgoing
+    pOut.reset();
+    for (int i = 2; i < int(myParticles.size()); i++) {
+      if (myParticles[i].statusPart != 1) continue;
+      myParticles[i].pxPart -= pxDiff;
+      myParticles[i].pyPart -= pyDiff;
+      myParticles[i].ePart   = sqrt(max(0., pow2(myParticles[i].pxPart) +
+          pow2(myParticles[i].pyPart) + pow2(myParticles[i].pzPart) +
+          pow2(myParticles[i].mPart)));
+      pOut += Vec4(myParticles[i].pxPart, myParticles[i].pyPart,
+                   myParticles[i].pzPart, myParticles[i].ePart);
+    }
+  }
+
+  // Differences in E/pZ and scaling factors
+  double de = (pOut.e()  - pIn.e());
+  double dp = (pOut.pz() - pIn.pz());
+  double a  = 1 + (de + dp) / 2. / myParticles[0].ePart;
+  double b  = 1 + (de - dp) / 2. / myParticles[1].ePart;
+
+  // Warn if resulting energy changes above warning threshold.
+  // Change in pz less than or equal to change in energy (incoming b
+  // quark can have mass at this stage for process 13). Note that for
+  // very small incoming momenta, the relative adjustment may be large,
+  // but still small in absolute terms.
+  if (abs(a - 1.) * myParticles[0].ePart > EWARNTHRESHOLD ||
+      abs(b - 1.) * myParticles[1].ePart > EWARNTHRESHOLD) {
+    cout << "Warning in LHAupAlpgen::setEvent: "
+         << "large rescaling factor" << endl;
+
+    // Debug printout
+    if (LHADEBUGRESCALE) {
+      printParticles();
+      cout << "de = " << de << ", dp = " << dp
+           << ", a = " << a << ", b = " << b << endl
+           << "Absolute energy change for incoming 0 = "
+           << abs(a - 1.) * myParticles[0].ePart << endl
+           << "Absolute energy change for incoming 1 = "
+           << abs(b - 1.) * myParticles[1].ePart << endl;
+    }
+  }
+  myParticles[0].ePart  *= a;
+  myParticles[0].pzPart *= a;
+  myParticles[1].ePart  *= b;
+  myParticles[1].pzPart *= b;
+
+  // Recalculate resonance four vectors
+  for (int i = 0; i < int(myParticles.size()); i++) {
+    if (myParticles[i].statusPart != 2) continue;
+
+    // Only mothers stored in LHA, so go through all
+    Vec4 resVec;
+    for (int j = 0; j < int(myParticles.size()); j++) {
+      if (myParticles[j].mother1Part - 1 != i) continue;
+      resVec += Vec4(myParticles[j].pxPart, myParticles[j].pyPart,
+                     myParticles[j].pzPart, myParticles[j].ePart);
+    }
+
+    myParticles[i].pxPart = resVec.px();
+    myParticles[i].pyPart = resVec.py();
+    myParticles[i].pzPart = resVec.pz();
+    myParticles[i].ePart  = resVec.e();
+  }
+
+  return true;
+}
+
+//==========================================================================
+
+// Main implementation of AlpgenHooks class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+// ----------------------------------------------------------------------
+
+// Constructor: provides the 'Alpgen:file' option by directly
+//              changing the Pythia 'Beams' settings
+
+AlpgenHooks::AlpgenHooks(Pythia &pythia) {
+
+  // If LHAupAlpgen needed, construct and pass to Pythia
+  string agFile = pythia.settings.word("Alpgen:file");
+  if (agFile != "void") {
+    LHAagPtr = make_shared<LHAupAlpgen>(agFile.c_str());
+    pythia.settings.mode("Beams:frameType", 5);
+    pythia.setLHAupPtr(LHAagPtr);
+  }
+}
+
+// ----------------------------------------------------------------------
+
+// Initialisation routine which is called by pythia.init().
+// This happens after the local pointers have been assigned and after
+// Pythia has processed the Beam information (and therefore LHEF header
+// information has been read in), but before any other internal
+// initialisation. Provides the remaining 'Alpgen:*' options.
+
+inline bool AlpgenHooks::initAfterBeams() {
+
+  // Read in ALPGEN specific configuration variables
+  bool setLightMasses = settingsPtr->flag("Alpgen:setLightMasses");
+  bool setHeavyMasses = settingsPtr->flag("Alpgen:setHeavyMasses");
+  bool setNjet   = settingsPtr->flag("Alpgen:setNjet");
+  bool setMLM    = settingsPtr->flag("Alpgen:setMLM");
+
+  // If ALPGEN parameters are present, then parse in AlpgenPar object
+  AlpgenPar par;
+  string parStr = infoPtr->header("AlpgenPar");
+  if (!parStr.empty()) {
+    par.parse(parStr);
+    par.printParams();
+  }
+
+  // Set masses if requested
+  if (setLightMasses) {
+    if (par.haveParam("mc")) particleDataPtr->m0(4,  par.getParam("mc"));
+    if (par.haveParam("mb")) particleDataPtr->m0(5,  par.getParam("mb"));
+  }
+  if (setHeavyMasses) {
+    if (par.haveParam("mt")) particleDataPtr->m0(6,  par.getParam("mt"));
+    if (par.haveParam("mz")) particleDataPtr->m0(23, par.getParam("mz"));
+    if (par.haveParam("mw")) particleDataPtr->m0(24, par.getParam("mw"));
+    if (par.haveParam("mh")) particleDataPtr->m0(25, par.getParam("mh"));
+  }
+
+  // Set MLM:nJets if requested
+  if (setNjet) {
+    if (par.haveParam("njets"))
+      settingsPtr->mode("JetMatching:nJet", par.getParamAsInt("njets"));
+    else
+      cout << "Warning in AlpgenHooks:init: "
+           << "no ALPGEN nJet parameter found" << endl;
+  }
+
+  // Set MLM merging parameters if requested
+  if (setMLM) {
+    if (par.haveParam("ptjmin") && par.haveParam("drjmin") &&
+        par.haveParam("etajmax")) {
+      double ptjmin = par.getParam("ptjmin");
+      ptjmin = max(ptjmin + 5., 1.2 * ptjmin);
+      settingsPtr->parm("JetMatching:eTjetMin",   ptjmin);
+      settingsPtr->parm("JetMatching:coneRadius", par.getParam("drjmin"));
+      settingsPtr->parm("JetMatching:etaJetMax",  par.getParam("etajmax"));
+
+    // Warn if setMLM requested, but parameters not present
+    } else {
+      cout << "Warning in AlpgenHooks:init: "
+           << "no ALPGEN merging parameters found" << endl;
+    }
+  }
+
+  // Initialisation complete.
+  return true;
+}
+
+//==========================================================================
+
+// Main implementation of MadgraphPar class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+//--------------------------------------------------------------------------
+
+// Constants: could be changed here if desired, but normally should not.
+// These are of technical nature, as described for each.
+
+// A zero threshold value for double comparisons.
+const double MadgraphPar::ZEROTHRESHOLD = 1e-10;
+
+//--------------------------------------------------------------------------
+
+// Parse an incoming Madgraph parameter file string
+
+inline bool MadgraphPar::parse(const string paramStr) {
+
+  // Loop over incoming lines
+  stringstream paramStream(paramStr);
+  string line;
+  while ( getline(paramStream, line) ) extractRunParam(line);
+  return true;
+
+}
+
+//--------------------------------------------------------------------------
+
+// Parse an incoming parameter line
+
+inline void MadgraphPar::extractRunParam(string line) {
+
+  // Extract information to the right of the final '!' character
+  size_t idz = line.find("#");
+  if ( !(idz == string::npos) ) return;
+  size_t idx = line.find("=");
+  size_t idy = line.find("!");
+  if (idy == string::npos) idy = line.size();
+  if (idx == string::npos) return;
+  string paramName = trim( line.substr( idx + 1, idy - idx - 1) );
+  string paramVal  = trim( line.substr( 0, idx) );
+  replace( paramVal.begin(), paramVal.end(), 'd', 'e');
+
+  // Simple tokeniser
+  istringstream iss(paramVal);
+  double val;
+  if (paramName.find(",") != string::npos) {
+    string        paramNameNow;
+    istringstream issName( paramName);
+    while ( getline(issName, paramNameNow, ',') ) {
+      iss >> val;
+      warnParamOverwrite( paramNameNow, val);
+      params[paramNameNow] = val;
+    }
+
+  // Default case: assume integer and double on the left
+  } else {
+    iss >> val;
+    warnParamOverwrite( paramName, val);
+    params[paramName] = val;
+  }
+}
+
+//--------------------------------------------------------------------------
+
+// Print parameters read from the '.par' file
+
+inline void MadgraphPar::printParams() {
+
+  // Loop over all stored parameters and print
+  cout << endl
+       << " *--------  Madgraph parameters  --------*" << endl;
+  for (map<string,double>::iterator it = params.begin();
+       it != params.end(); ++it)
+    cout << " |  " << left << setw(15) << it->first
+         << "  |  " << right << setw(15) << it->second
+         << "  |" << endl;
+  cout << " *---------------------------------------*" << endl;
+}
+
+//--------------------------------------------------------------------------
+
+// Warn if a parameter is going to be overwriten
+
+inline void MadgraphPar::warnParamOverwrite(const string &paramIn,
+  double val) {
+
+  // Check if present and if new value is different
+  if (haveParam(paramIn) &&
+      abs(getParam(paramIn) - val) > ZEROTHRESHOLD) {
+    cout << "Warning in LHAupAlpgen::"
+         << "warnParamOverwrite: overwriting existing parameter"
+         << paramIn << endl;
+  }
+}
+
+//--------------------------------------------------------------------------
+
+// Simple string trimmer
+
+inline string MadgraphPar::trim(string s) {
+
+  // Remove whitespace in incoming string
+  size_t i;
+  if ( (i = s.find_last_not_of(" \t\r\n")) != string::npos)
+    s = s.substr(0, i + 1);
+  if ( (i = s.find_first_not_of(" \t\r\n")) != string::npos)
+    s = s.substr(i);
+  return s;
+}
+
+//==========================================================================
+
+} // end namespace Pythia8
diff -rupN pythia8306_original/src/Info.cc pythia8306_patched/src/Info.cc
--- pythia8306_original/src/Info.cc	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/src/Info.cc	2023-06-27 02:09:11.960196135 +0200
@@ -178,9 +178,9 @@ double Info::weightSum() const {
 
 // List of all hard processes switched on.
 
-vector<int> Info::codesHard() {
+vector<int> Info::codesHard() const {
   vector<int> codesNow;
-  for (map<int, long>::iterator nTryEntry = nTryM.begin();
+  for (map<int, long>::const_iterator nTryEntry = nTryM.begin();
     nTryEntry != nTryM.end(); ++nTryEntry)
       codesNow.push_back( nTryEntry->first );
   return codesNow;
diff -rupN pythia8306_original/src/JetMatching.cc pythia8306_patched/src/JetMatching.cc
--- pythia8306_original/src/JetMatching.cc	1970-01-01 01:00:00.000000000 +0100
+++ pythia8306_patched/src/JetMatching.cc	2023-06-27 02:09:11.956196135 +0200
@@ -0,0 +1,1717 @@
+#include "Pythia8Plugins/JetMatching.h"
+
+// GAMBIT: We moved the below definitions from GeneratorInput.h
+//         to this source file to allow easy BOSSing
+
+
+namespace Pythia8 {
+
+//--------------------------------------------------------------------------
+
+// Find next cluster pair to join.
+
+void HJSlowJet::findNext() {
+
+  // Find smallest of diB, dij.
+  if (clSize > 0) {
+    iMin =  0;
+    jMin = -1;
+    dMin = 1.0/TINY;
+    // Remove the possibility of choosing a beam clustering
+    for (int i = 1; i < clSize; ++i) {
+      for (int j = 0; j < i; ++j) {
+        if (dij[i*(i-1)/2 + j] < dMin) {
+          iMin = i;
+          jMin = j;
+          dMin = dij[i*(i-1)/2 + j];
+        }
+      }
+    }
+
+  // If no clusters left then instead default values.
+  } else {
+    iMin = -1;
+    jMin = -1;
+    dMin = 0.;
+  }
+
+}
+//==========================================================================
+
+// Main implementation of JetMatching class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+//--------------------------------------------------------------------------
+
+// Constants to be changed for debug printout or extra checks.
+const bool JetMatching::MATCHINGDEBUG = false;
+const bool JetMatching::MATCHINGCHECK = false;
+
+//--------------------------------------------------------------------------
+
+// Early parton level veto (before beam remnants and resonance showers)
+
+inline bool JetMatching::doVetoPartonLevelEarly(const Event& event) {
+
+  // 1) Sort the original incoming process. After this step is performed,
+  //    the following assignments have been made:
+  //    eventProcessOrig - the original incoming process
+  //    eventProcess     - the final-state of the incoming process with
+  //                       resonance decays removed (and resonances
+  //                       themselves now with positive status code)
+  //    typeIdx[0/1/2]   - Indices into 'eventProcess' of
+  //                       light jets/heavy jets/other
+  //    typeSet[0/1/2]   - Indices into 'event' of light jets/heavy jets/other
+  //    workEvent        - partons from the hardest subsystem + ISR + FSR only
+  sortIncomingProcess(event);
+
+  // For the shower-kT scheme, do not perform any veto here, as any vetoing
+  // will already have taken place in doVetoStep.
+  if ( doShowerKt ) return false;
+
+  // Debug printout.
+  if (MATCHINGDEBUG) {
+    // Begin
+    cout << endl << "-------- Begin Madgraph Debug --------" << endl;
+    // Original incoming process
+    cout << endl << "Original incoming process:";
+    eventProcessOrig.list();
+    // Final-state of original incoming process
+    cout << endl << "Final-state incoming process:";
+    eventProcess.list();
+    // List categories of sorted particles
+    for (size_t i = 0; i < typeIdx[0].size(); i++)
+      cout << ((i == 0) ? "Light jets: " : ", ")   << setw(3) << typeIdx[0][i];
+    if( typeIdx[0].size()== 0 )
+      cout << "Light jets: None";
+
+    for (size_t i = 0; i < typeIdx[1].size(); i++)
+      cout << ((i == 0) ? "\nHeavy jets: " : ", ") << setw(3) << typeIdx[1][i];
+    for (size_t i = 0; i < typeIdx[2].size(); i++)
+      cout << ((i == 0) ? "\nOther:      " : ", ") << setw(3) << typeIdx[2][i];
+    // Full event at this stage
+    cout << endl << endl << "Event:";
+    event.list();
+    // Work event (partons from hardest subsystem + ISR + FSR)
+    cout << endl << "Work event:";
+    workEvent.list();
+  }
+
+  // 2) Light/heavy jets: iType = 0 (light jets), 1 (heavy jets)
+  int iTypeEnd = (typeIdx[2].empty()) ? 2 : 3;
+  for (int iType = 0; iType < iTypeEnd; iType++) {
+
+    // 2a) Find particles which will be passed from the jet algorithm.
+    //     Input from 'workEvent' and output in 'workEventJet'.
+    jetAlgorithmInput(event, iType);
+
+    // Debug printout.
+    if (MATCHINGDEBUG) {
+      // Jet algorithm event
+      cout << endl << "Jet algorithm event (iType = " << iType << "):";
+      workEventJet.list();
+    }
+
+    // 2b) Run jet algorithm on 'workEventJet'.
+    //     Output is stored in jetMomenta.
+    runJetAlgorithm();
+
+    // 2c) Match partons to jets and decide if veto is necessary
+    if (matchPartonsToJets(iType) == true) {
+      // Debug printout.
+      if (MATCHINGDEBUG) {
+        cout << endl << "Event vetoed" << endl
+             << "----------  End MLM Debug  ----------" << endl;
+      }
+      return true;
+    }
+  }
+
+  // Debug printout.
+  if (MATCHINGDEBUG) {
+    cout << endl << "Event accepted" << endl
+         << "----------  End MLM Debug  ----------" << endl;
+  }
+
+  // If we reached here, then no veto
+  return false;
+
+}
+
+//==========================================================================
+
+// Main implementation of Alpgen UserHooks class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+//--------------------------------------------------------------------------
+
+// Constants: could be changed here if desired, but normally should not.
+// These are of technical nature, as described for each.
+
+// The energy of ghost particles. For technical reasons, this cannot be
+// set arbitrarily low, see 'Particle::TINY' in 'Event.cc' for details.
+const double JetMatchingAlpgen::GHOSTENERGY   = 1e-15;
+
+// A zero threshold value for double comparisons.
+const double JetMatchingAlpgen::ZEROTHRESHOLD = 1e-10;
+
+//--------------------------------------------------------------------------
+
+// Function to sort typeIdx vectors into descending eT/pT order.
+// Uses a selection sort, as number of partons generally small
+// and so efficiency not a worry.
+
+inline void JetMatchingAlpgen::sortTypeIdx(vector < int > &vecIn) {
+  for (size_t i = 0; i < vecIn.size(); i++) {
+    size_t jMax = i;
+    double vMax = (jetAlgorithm == 1) ?
+      eventProcess[vecIn[i]].eT() :
+      eventProcess[vecIn[i]].pT();
+    for (size_t j = i + 1; j < vecIn.size(); j++) {
+      double vNow = (jetAlgorithm == 1)
+        ? eventProcess[vecIn[j]].eT() : eventProcess[vecIn[j]].pT();
+      if (vNow > vMax) {
+        vMax = vNow;
+        jMax = j;
+      }
+    }
+    if (jMax != i) swap(vecIn[i], vecIn[jMax]);
+  }
+}
+
+//--------------------------------------------------------------------------
+
+// Initialisation routine automatically called from Pythia::init().
+// Setup all parts needed for the merging.
+
+inline bool JetMatchingAlpgen::initAfterBeams() {
+
+  // Read in parameters
+  doMerge         = settingsPtr->flag("JetMatching:merge");
+  jetAlgorithm    = settingsPtr->mode("JetMatching:jetAlgorithm");
+  nJet            = settingsPtr->mode("JetMatching:nJet");
+  nJetMax         = settingsPtr->mode("JetMatching:nJetMax");
+  eTjetMin        = settingsPtr->parm("JetMatching:eTjetMin");
+  coneRadius      = settingsPtr->parm("JetMatching:coneRadius");
+  etaJetMax       = settingsPtr->parm("JetMatching:etaJetMax");
+  doShowerKt      = settingsPtr->flag("JetMatching:doShowerKt");
+
+  // Use etaJetMax + coneRadius in input to jet algorithms
+  etaJetMaxAlgo   = etaJetMax + coneRadius;
+
+  // CellJet specific
+  nEta            = settingsPtr->mode("JetMatching:nEta");
+  nPhi            = settingsPtr->mode("JetMatching:nPhi");
+  eTseed          = settingsPtr->parm("JetMatching:eTseed");
+  eTthreshold     = settingsPtr->parm("JetMatching:eTthreshold");
+
+  // SlowJet specific
+  slowJetPower    = settingsPtr->mode("JetMatching:slowJetPower");
+  coneMatchLight  = settingsPtr->parm("JetMatching:coneMatchLight");
+  coneRadiusHeavy = settingsPtr->parm("JetMatching:coneRadiusHeavy");
+  if (coneRadiusHeavy < 0.) coneRadiusHeavy = coneRadius;
+  coneMatchHeavy  = settingsPtr->parm("JetMatching:coneMatchHeavy");
+
+  // Matching procedure
+  jetAllow        = settingsPtr->mode("JetMatching:jetAllow");
+  jetMatch        = settingsPtr->mode("JetMatching:jetMatch");
+  exclusiveMode   = settingsPtr->mode("JetMatching:exclusive");
+
+  // If not merging, then done
+  if (!doMerge) return true;
+
+  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
+  if (exclusiveMode == 2) {
+
+    // No nJet or nJetMax, so default to exclusive mode
+    if (nJet < 0 || nJetMax < 0) {
+      errorMsg("Warning in JetMatchingAlpgen:init: "
+          "missing jet multiplicity information; running in exclusive mode");
+      exclusive = true;
+
+    // Inclusive if nJet == nJetMax, exclusive otherwise
+    } else {
+      exclusive = (nJet == nJetMax) ? false : true;
+    }
+
+  // Otherwise, just set as given
+  } else {
+    exclusive = (exclusiveMode == 0) ? false : true;
+  }
+
+  // Initialise chosen jet algorithm. CellJet.
+  if (jetAlgorithm == 1) {
+
+    // Extra options for CellJet. nSel = 1 means that all final-state
+    // particles are taken and we retain control of what to select.
+    // smear/resolution/upperCut are not used and are set to default values.
+    int    nSel = 2, smear = 0;
+    double resolution = 0.5, upperCut = 2.;
+    cellJet = new CellJet(etaJetMaxAlgo, nEta, nPhi, nSel,
+                          smear, resolution, upperCut, eTthreshold);
+
+  // SlowJet
+  } else if (jetAlgorithm == 2) {
+    slowJet = new SlowJet(slowJetPower, coneRadius, eTjetMin, etaJetMaxAlgo);
+  }
+
+  // Check the jetMatch parameter; option 2 only works with SlowJet
+  if (jetAlgorithm == 1 && jetMatch == 2) {
+    errorMsg("Warning in JetMatchingAlpgen:init: "
+        "jetMatch = 2 only valid with SlowJet algorithm. "
+        "Reverting to jetMatch = 1");
+    jetMatch = 1;
+  }
+
+  // Setup local event records
+  eventProcessOrig.init("(eventProcessOrig)", particleDataPtr);
+  eventProcess.init("(eventProcess)", particleDataPtr);
+  workEventJet.init("(workEventJet)", particleDataPtr);
+
+  // Print information
+  string jetStr  = (jetAlgorithm ==  1) ? "CellJet" :
+                   (slowJetPower == -1) ? "anti-kT" :
+                   (slowJetPower ==  0) ? "C/A"     :
+                   (slowJetPower ==  1) ? "kT"      : "unknown";
+  string modeStr = (exclusive)         ? "exclusive" : "inclusive";
+  stringstream nJetStr, nJetMaxStr;
+  if (nJet >= 0)    nJetStr    << nJet;    else nJetStr    << "unknown";
+  if (nJetMax >= 0) nJetMaxStr << nJetMax; else nJetMaxStr << "unknown";
+  cout << endl
+       << " *-------  MLM matching parameters  -------*" << endl
+       << " |  nJet                |  " << setw(14)
+       << nJetStr.str() << "  |" << endl
+       << " |  nJetMax             |  " << setw(14)
+       << nJetMaxStr.str() << "  |" << endl
+       << " |  Jet algorithm       |  " << setw(14)
+       << jetStr << "  |" << endl
+       << " |  eTjetMin            |  " << setw(14)
+       << eTjetMin << "  |" << endl
+       << " |  coneRadius          |  " << setw(14)
+       << coneRadius << "  |" << endl
+       << " |  etaJetMax           |  " << setw(14)
+       << etaJetMax << "  |" << endl
+       << " |  jetAllow            |  " << setw(14)
+       << jetAllow << "  |" << endl
+       << " |  jetMatch            |  " << setw(14)
+       << jetMatch << "  |" << endl
+       << " |  coneMatchLight      |  " << setw(14)
+       << coneMatchLight << "  |" << endl
+       << " |  coneRadiusHeavy     |  " << setw(14)
+       << coneRadiusHeavy << "  |" << endl
+       << " |  coneMatchHeavy      |  " << setw(14)
+       << coneMatchHeavy << "  |" << endl
+       << " |  Mode                |  " << setw(14)
+       << modeStr << "  |" << endl
+       << " *-----------------------------------------*" << endl;
+
+  return true;
+}
+
+//--------------------------------------------------------------------------
+
+// Step (1): sort the incoming particles
+
+inline void JetMatchingAlpgen::sortIncomingProcess(const Event &event) {
+
+  // Remove resonance decays from original process and keep only final
+  // state. Resonances will have positive status code after this step.
+  omitResonanceDecays(eventProcessOrig, true);
+  eventProcess = workEvent;
+
+  // Sort original process final state into light/heavy jets and 'other'.
+  // Criteria:
+  //   1 <= ID <= 5 and massless, or ID == 21 --> light jet (typeIdx[0])
+  //   4 <= ID <= 6 and massive               --> heavy jet (typeIdx[1])
+  //   All else                               --> other     (typeIdx[2])
+  // Note that 'typeIdx' stores indices into 'eventProcess' (after resonance
+  // decays are omitted), while 'typeSet' stores indices into the original
+  // process record, 'eventProcessOrig', but these indices are also valid
+  // in 'event'.
+  for (int i = 0; i < 3; i++) {
+    typeIdx[i].clear();
+    typeSet[i].clear();
+  }
+  for (int i = 0; i < eventProcess.size(); i++) {
+    // Ignore nonfinal and default to 'other'
+    if (!eventProcess[i].isFinal()) continue;
+    int idx = 2;
+
+    // Light jets
+    if (eventProcess[i].id() == ID_GLUON
+      || (eventProcess[i].idAbs() <= ID_BOT
+      && abs(eventProcess[i].m()) < ZEROTHRESHOLD)) idx = 0;
+
+    // Heavy jets
+    else if (eventProcess[i].idAbs() >= ID_CHARM
+      && eventProcess[i].idAbs() <= ID_TOP) idx = 1;
+
+    // Store
+    typeIdx[idx].push_back(i);
+    typeSet[idx].insert(eventProcess[i].daughter1());
+  }
+
+  // Extract partons from hardest subsystem + ISR + FSR only into
+  // workEvent. Note no resonance showers or MPIs.
+  subEvent(event);
+}
+
+//--------------------------------------------------------------------------
+
+// Step (2a): pick which particles to pass to the jet algorithm
+
+inline void JetMatchingAlpgen::jetAlgorithmInput(const Event &event,
+  int iType) {
+
+  // Take input from 'workEvent' and put output in 'workEventJet'
+  workEventJet = workEvent;
+
+  // Loop over particles and decide what to pass to the jet algorithm
+  for (int i = 0; i < workEventJet.size(); ++i) {
+    if (!workEventJet[i].isFinal()) continue;
+
+    // jetAllow option to disallow certain particle types
+    if (jetAllow == 1) {
+
+      // Original AG+Py6 algorithm explicitly excludes tops,
+      // leptons and photons.
+      int id = workEventJet[i].idAbs();
+      if ( (id >= ID_LEPMIN && id <= ID_LEPMAX) || id == ID_TOP
+        || id == ID_PHOTON) {
+        workEventJet[i].statusNeg();
+        continue;
+      }
+    }
+
+    // Get the index of this particle in original event
+    int idx = workEventJet[i].daughter1();
+
+    // Start with particle idx, and afterwards track mothers
+    while (true) {
+
+      // Light jets
+      if (iType == 0) {
+
+        // Do not include if originates from heavy jet or 'other'
+        if (typeSet[1].find(idx) != typeSet[1].end() ||
+            typeSet[2].find(idx) != typeSet[2].end()) {
+          workEventJet[i].statusNeg();
+          break;
+        }
+
+        // Made it to start of event record so done
+        if (idx == 0) break;
+        // Otherwise next mother and continue
+        idx = event[idx].mother1();
+
+      // Heavy jets
+      } else if (iType == 1) {
+
+        // Only include if originates from heavy jet
+        if (typeSet[1].find(idx) != typeSet[1].end()) break;
+
+        // Made it to start of event record with no heavy jet mother,
+        // so DO NOT include particle
+        if (idx == 0) {
+          workEventJet[i].statusNeg();
+          break;
+        }
+
+        // Otherwise next mother and continue
+        idx = event[idx].mother1();
+
+      // Other jets
+      } else if (iType == 2) {
+
+        // Only include if originates from other jet
+        if (typeSet[2].find(idx) != typeSet[2].end()) break;
+
+        // Made it to start of event record with no heavy jet mother,
+        // so DO NOT include particle
+        if (idx == 0) {
+          workEventJet[i].statusNeg();
+          break;
+        }
+
+        // Otherwise next mother and continue
+        idx = event[idx].mother1();
+
+      } // if (iType)
+    } // while (true)
+  } // for (i)
+
+  // For jetMatch = 2, insert ghost particles corresponding to
+  // each hard parton in the original process
+  if (jetMatch == 2) {
+    for (int i = 0; i < int(typeIdx[iType].size()); i++) {
+      // Get y/phi of the parton
+      Vec4   pIn = eventProcess[typeIdx[iType][i]].p();
+      double y   = pIn.rap();
+      double phi = pIn.phi();
+
+      // Create a ghost particle and add to the workEventJet
+      double e   = GHOSTENERGY;
+      double e2y = exp(2. * y);
+      double pz  = e * (e2y - 1.) / (e2y + 1.);
+      double pt  = sqrt(e*e - pz*pz);
+      double px  = pt * cos(phi);
+      double py  = pt * sin(phi);
+      workEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0, px, py, pz, e);
+
+      // Extra check on reconstructed y/phi values. If many warnings
+      // of this type, GHOSTENERGY may be set too low.
+      if (MATCHINGCHECK) {
+      int lastIdx = workEventJet.size() - 1;
+      if (abs(y   - workEventJet[lastIdx].y())   > ZEROTHRESHOLD ||
+          abs(phi - workEventJet[lastIdx].phi()) > ZEROTHRESHOLD)
+        errorMsg("Warning in JetMatchingAlpgen:jetAlgorithmInput: "
+            "ghost particle y/phi mismatch");
+      }
+
+    } // for (i)
+  } // if (jetMatch == 2)
+}
+
+//--------------------------------------------------------------------------
+
+// Step (2b): run jet algorithm and provide common output
+
+inline void JetMatchingAlpgen::runJetAlgorithm() {
+
+  // Run the jet clustering algorithm
+  if (jetAlgorithm == 1)
+    cellJet->analyze(workEventJet, eTjetMin, coneRadius, eTseed);
+  else
+    slowJet->analyze(workEventJet);
+
+  // Extract four-momenta of jets with |eta| < etaJetMax and
+  // put into jetMomenta. Note that this is done backwards as
+  // jets are removed with SlowJet.
+  jetMomenta.clear();
+  int iJet = (jetAlgorithm == 1) ? cellJet->size() - 1:
+                                   slowJet->sizeJet() - 1;
+  for (int i = iJet; i > -1; i--) {
+    Vec4 jetMom = (jetAlgorithm == 1) ? cellJet->pMassive(i) :
+                                        slowJet->p(i);
+    double eta = jetMom.eta();
+
+    if (abs(eta) > etaJetMax) {
+      if (jetAlgorithm == 2) slowJet->removeJet(i);
+      continue;
+    }
+    jetMomenta.push_back(jetMom);
+  }
+
+  // Reverse jetMomenta to restore eT/pT ordering
+  reverse(jetMomenta.begin(), jetMomenta.end());
+}
+
+//--------------------------------------------------------------------------
+
+// Step (2c): veto decision (returning true vetoes the event)
+
+inline bool JetMatchingAlpgen::matchPartonsToJets(int iType) {
+
+  // Use two different routines for light/heavy jets as
+  // different veto conditions and for clarity
+  if (iType == 0) return (matchPartonsToJetsLight() > 0);
+  else if (iType == 1) return (matchPartonsToJetsHeavy() > 0);
+  else if (iType == 2) return false;
+  return true;
+}
+
+//--------------------------------------------------------------------------
+
+// Step(2c): light jets
+// Return codes are given indicating the reason for a veto.
+// Although not currently used, they are a useful debugging tool:
+//   0 = no veto
+//   1 = veto as number of jets less than number of partons
+//   2 = veto as exclusive mode and number of jets greater than
+//       number of partons
+//   3 = veto as inclusive mode and there would be an extra jet
+//       that is harder than any matched soft jet
+//   4 = veto as there is a parton which does not match a jet
+
+inline int JetMatchingAlpgen::matchPartonsToJetsLight() {
+
+  // Always veto if number of jets is less than original number of jets
+  if (jetMomenta.size() < typeIdx[0].size()) return LESS_JETS;
+  // Veto if in exclusive mode and number of jets bigger than original
+  if (exclusive && jetMomenta.size() > typeIdx[0].size()) return MORE_JETS;
+
+  // Sort partons by eT/pT
+  sortTypeIdx(typeIdx[0]);
+
+  // Number of hard partons
+  int nParton = typeIdx[0].size();
+
+  // Keep track of which jets have been assigned a hard parton
+  vector < bool > jetAssigned;
+  jetAssigned.assign(jetMomenta.size(), false);
+
+  // Jet matching procedure: (1) deltaR between partons and jets
+  if (jetMatch == 1) {
+
+    // Loop over light hard partons and get 4-momentum
+    for (int i = 0; i < nParton; i++) {
+      Vec4 p1 = eventProcess[typeIdx[0][i]].p();
+
+      // Track which jet has the minimal dR measure with this parton
+      int    jMin  = -1;
+      double dRmin = 0.;
+
+      // Loop over all jets (skipping those already assigned).
+      for (int j = 0; j < int(jetMomenta.size()); j++) {
+        if (jetAssigned[j]) continue;
+
+        // DeltaR between parton/jet and store if minimum
+        double dR = (jetAlgorithm == 1)
+          ? REtaPhi(p1, jetMomenta[j]) : RRapPhi(p1, jetMomenta[j]);
+        if (jMin < 0 || dR < dRmin) {
+          dRmin = dR;
+          jMin  = j;
+        }
+      } // for (j)
+
+      // Check for jet-parton match
+      if (jMin >= 0 && dRmin < coneRadius * coneMatchLight) {
+
+        // If the matched jet is not one of the nParton hardest jets,
+        // the extra left over jet would be harder than some of the
+        // matched jets. This is disallowed, so veto.
+        if (jMin >= nParton) return HARD_JET;
+
+        // Mark jet as assigned.
+        jetAssigned[jMin] = true;
+
+      // If no match, then event will be vetoed in all cases
+      } else return UNMATCHED_PARTON;
+
+    } // for (i)
+
+  // Jet matching procedure: (2) ghost particles in SlowJet
+  } else {
+
+    // Loop over added 'ghost' particles and find if assigned to a jet
+    for (int i = workEventJet.size() - nParton;
+        i < workEventJet.size(); i++) {
+      int jMin = slowJet->jetAssignment(i);
+
+      // Veto if:
+      //  1) not one of nParton hardest jets
+      //  2) not assigned to a jet
+      //  3) jet has already been assigned
+      if (jMin >= nParton)               return HARD_JET;
+      if (jMin < 0 || jetAssigned[jMin]) return UNMATCHED_PARTON;
+
+      // Mark jet as assigned
+      jetAssigned[jMin] = true;
+
+    } // for (i)
+  } // if (jetMatch)
+
+  // Minimal eT/pT (CellJet/SlowJet) of matched light jets. Needed
+  // later for heavy jet vetos in inclusive mode.
+  if (nParton > 0)
+    eTpTlightMin = (jetAlgorithm == 1) ? jetMomenta[nParton - 1].eT()
+                                       : jetMomenta[nParton - 1].pT();
+  else
+    eTpTlightMin = -1.;
+
+  // No veto
+  return NONE;
+}
+
+//--------------------------------------------------------------------------
+
+// Step(2c): heavy jets
+// Return codes are given indicating the reason for a veto.
+// Although not currently used, they are a useful debugging tool:
+//   0 = no veto as there are no extra jets present
+//   1 = veto as in exclusive mode and extra jets present
+//   2 = veto as in inclusive mode and extra jets were harder
+//       than any matched light jet
+
+inline int JetMatchingAlpgen::matchPartonsToJetsHeavy() {
+
+  // If there are no extra jets, then accept
+  if (jetMomenta.empty()) return NONE;
+
+  // Number of hard partons
+  int nParton = typeIdx[1].size();
+
+  // Remove jets that are close to heavy quarks
+  set < int > removeJets;
+
+  // Jet matching procedure: (1) deltaR between partons and jets
+  if (jetMatch == 1) {
+
+    // Loop over heavy hard partons and get 4-momentum
+    for (int i = 0; i < nParton; i++) {
+      Vec4 p1 = eventProcess[typeIdx[1][i]].p();
+
+      // Loop over all jets, find dR and mark for removal if match
+      for (int j = 0; j < int(jetMomenta.size()); j++) {
+        double dR = (jetAlgorithm == 1) ?
+            REtaPhi(p1, jetMomenta[j]) : RRapPhi(p1, jetMomenta[j]);
+        if (dR < coneRadiusHeavy * coneMatchHeavy)
+          removeJets.insert(j);
+
+      } // for (j)
+    } // for (i)
+
+  // Jet matching procedure: (2) ghost particles in SlowJet
+  } else {
+
+    // Loop over added 'ghost' particles and if assigned to a jet
+    // then mark this jet for removal
+    for (int i = workEventJet.size() - nParton;
+        i < workEventJet.size(); i++) {
+      int jMin = slowJet->jetAssignment(i);
+      if (jMin >= 0) removeJets.insert(jMin);
+    }
+
+  }
+
+  // Remove jets (backwards order to not disturb indices)
+  for (set < int >::reverse_iterator it  = removeJets.rbegin();
+                                     it != removeJets.rend(); it++)
+    jetMomenta.erase(jetMomenta.begin() + *it);
+
+  // Handle case if there are still extra jets
+  if (!jetMomenta.empty()) {
+
+    // Exclusive mode, so immediate veto
+    if (exclusive) return MORE_JETS;
+
+    // Inclusive mode; extra jets must be softer than any matched light jet
+    else if (eTpTlightMin >= 0.)
+      for (size_t j = 0; j < jetMomenta.size(); j++) {
+        // CellJet uses eT, SlowJet uses pT
+        if ( (jetAlgorithm == 1 && jetMomenta[j].eT() > eTpTlightMin) ||
+             (jetAlgorithm == 2 && jetMomenta[j].pT() > eTpTlightMin) )
+          return HARD_JET;
+      }
+
+  } // if (!jetMomenta.empty())
+
+  // No extra jets were present so no veto
+  return NONE;
+}
+
+//==========================================================================
+
+// Main implementation of Madgraph UserHooks class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+//--------------------------------------------------------------------------
+
+// Initialisation routine automatically called from Pythia::init().
+// Setup all parts needed for the merging.
+
+inline bool JetMatchingMadgraph::initAfterBeams() {
+
+  // Initialise values for stored jet matching veto inputs.
+  pTfirstSave = -1.;
+  processSubsetSave.init("(eventProcess)", particleDataPtr);
+  workEventJetSave.init("(workEventJet)", particleDataPtr);
+
+  // Read in Madgraph specific configuration variables
+  bool setMad    = settingsPtr->flag("JetMatching:setMad");
+
+  // If Madgraph parameters are present, then parse in MadgraphPar object
+  MadgraphPar par;
+  string parStr = infoPtr->header("MGRunCard");
+  if (!parStr.empty()) {
+    par.parse(parStr);
+    par.printParams();
+  }
+
+  // Set Madgraph merging parameters from the file if requested
+  if (setMad) {
+    if ( par.haveParam("xqcut")    && par.haveParam("maxjetflavor")
+      && par.haveParam("alpsfact") && par.haveParam("ickkw") ) {
+      settingsPtr->flag("JetMatching:merge", par.getParam("ickkw"));
+      settingsPtr->parm("JetMatching:qCut", par.getParam("xqcut"));
+      settingsPtr->mode("JetMatching:nQmatch",
+        par.getParamAsInt("maxjetflavor"));
+      settingsPtr->parm("JetMatching:clFact",
+        clFact = par.getParam("alpsfact"));
+      if (par.getParamAsInt("ickkw") == 0)
+        errorMsg("Error in JetMatchingMadgraph:init: "
+          "Madgraph file parameters are not set for merging");
+
+    // Warn if setMad requested, but one or more parameters not present
+    } else {
+       errorMsg("Warning in JetMatchingMadgraph:init: "
+          "Madgraph merging parameters not found");
+       if (!par.haveParam("xqcut")) errorMsg("Warning in "
+          "JetMatchingMadgraph:init: No xqcut");
+       if (!par.haveParam("ickkw")) errorMsg("Warning in "
+          "JetMatchingMadgraph:init: No ickkw");
+       if (!par.haveParam("maxjetflavor")) errorMsg("Warning in "
+          "JetMatchingMadgraph:init: No maxjetflavor");
+       if (!par.haveParam("alpsfact")) errorMsg("Warning in "
+          "JetMatchingMadgraph:init: No alpsfact");
+    }
+  }
+
+  // Read in FxFx matching parameters
+  doFxFx       = settingsPtr->flag("JetMatching:doFxFx");
+  nPartonsNow  = settingsPtr->mode("JetMatching:nPartonsNow");
+  qCutME       = settingsPtr->parm("JetMatching:qCutME");
+  qCutMESq     = pow(qCutME,2);
+
+  // Read in Madgraph merging parameters
+  doMerge      = settingsPtr->flag("JetMatching:merge");
+  doShowerKt   = settingsPtr->flag("JetMatching:doShowerKt");
+  qCut         = settingsPtr->parm("JetMatching:qCut");
+  nQmatch      = settingsPtr->mode("JetMatching:nQmatch");
+  clFact       = settingsPtr->parm("JetMatching:clFact");
+
+  // Read in jet algorithm parameters
+  jetAlgorithm   = settingsPtr->mode("JetMatching:jetAlgorithm");
+  nJetMax        = settingsPtr->mode("JetMatching:nJetMax");
+  eTjetMin       = settingsPtr->parm("JetMatching:eTjetMin");
+  coneRadius     = settingsPtr->parm("JetMatching:coneRadius");
+  etaJetMax      = settingsPtr->parm("JetMatching:etaJetMax");
+  slowJetPower   = settingsPtr->mode("JetMatching:slowJetPower");
+
+  // Matching procedure
+  jetAllow       = settingsPtr->mode("JetMatching:jetAllow");
+  exclusiveMode  = settingsPtr->mode("JetMatching:exclusive");
+  qCutSq         = pow(qCut,2);
+  etaJetMaxAlgo  = etaJetMax;
+
+  // Read if veto should be performed internally.
+  performVeto    = settingsPtr->flag("JetMatching:doVeto");
+
+  // If not merging, then done
+  if (!doMerge) return true;
+
+  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
+  if (exclusiveMode == 2) {
+
+    // No nJet or nJetMax, so default to exclusive mode
+    if (nJetMax < 0) {
+      errorMsg("Warning in JetMatchingMadgraph:init: "
+        "missing jet multiplicity information; running in exclusive mode");
+      exclusiveMode = 1;
+    }
+  }
+
+  // Initialise chosen jet algorithm.
+  // Currently, this only supports the kT-algorithm in SlowJet.
+  // Use the QCD distance measure by default.
+  jetAlgorithm = 2;
+  slowJetPower = 1;
+  slowJet = new SlowJet(slowJetPower, coneRadius, eTjetMin,
+    etaJetMaxAlgo, 2, 2, NULL, false);
+
+  // For FxFx, also initialise jet algorithm to define matrix element jets.
+  // Currently, this only supports the kT-algorithm in SlowJet.
+  // Use the QCD distance measure by default.
+  slowJetHard = new SlowJet(slowJetPower, coneRadius, qCutME,
+    etaJetMaxAlgo, 2, 2, NULL, false);
+
+  // To access the DJR's
+  slowJetDJR = new SlowJet(slowJetPower, coneRadius, qCutME,
+    etaJetMaxAlgo, 2, 2, NULL, false);
+
+  // A special version of SlowJet to handle heavy and other partons
+  hjSlowJet = new HJSlowJet(slowJetPower, coneRadius, 0.0,
+    100.0, 1, 2, NULL, false, true);
+
+  // Setup local event records
+  eventProcessOrig.init("(eventProcessOrig)", particleDataPtr);
+  eventProcess.init("(eventProcess)", particleDataPtr);
+  workEventJet.init("(workEventJet)", particleDataPtr);
+
+  // Print information
+  string jetStr  = (jetAlgorithm ==  1) ? "CellJet" :
+                   (slowJetPower == -1) ? "anti-kT" :
+                   (slowJetPower ==  0) ? "C/A"     :
+                   (slowJetPower ==  1) ? "kT"      : "unknown";
+  string modeStr = (exclusiveMode)         ? "exclusive" : "inclusive";
+  cout << endl
+       << " *-----  Madgraph matching parameters  -----*" << endl
+       << " |  qCut                |  " << setw(14)
+       << qCut << "  |" << endl
+       << " |  nQmatch             |  " << setw(14)
+       << nQmatch << "  |" << endl
+       << " |  clFact              |  " << setw(14)
+       << clFact << "  |" << endl
+       << " |  Jet algorithm       |  " << setw(14)
+       << jetStr << "  |" << endl
+       << " |  eTjetMin            |  " << setw(14)
+       << eTjetMin << "  |" << endl
+       << " |  etaJetMax           |  " << setw(14)
+       << etaJetMax << "  |" << endl
+       << " |  jetAllow            |  " << setw(14)
+       << jetAllow << "  |" << endl
+       << " |  Mode                |  " << setw(14)
+       << modeStr << "  |" << endl
+       << " *-----------------------------------------*" << endl;
+
+  return true;
+}
+
+//--------------------------------------------------------------------------
+
+// Process level vetos
+
+inline bool JetMatchingMadgraph::doVetoProcessLevel(Event& process) {
+
+  eventProcessOrig = process;
+
+  // Setup for veto if hard ME has too many partons.
+  // This is done to achieve consistency with the Pythia6 implementation.
+
+  // Clear the event of MPI systems and resonace decay products. Store trimmed
+  // event in workEvent.
+  sortIncomingProcess(process);
+
+  // Veto in case the hard input matrix element already has too many partons.
+  if ( !doFxFx && int(typeIdx[0].size()) > nJetMax )
+    return true;
+  if ( doFxFx && npNLO() < nJetMax && int(typeIdx[0].size()) > nJetMax )
+    return true;
+
+  // Done
+  return false;
+
+}
+
+//--------------------------------------------------------------------------
+
+inline bool JetMatchingMadgraph::doVetoStep(int iPos, int nISR, int nFSR,
+  const Event& event)  {
+
+  // Do not perform any veto if not in the Shower-kT scheme.
+  if ( !doShowerKt ) return false;
+
+  // Do nothing for emissions after the first one.
+  if ( nISR + nFSR > 1 ) return false;
+
+  // Do nothing in resonance decay showers.
+  if (iPos == 5) return false;
+
+  // Clear the event of MPI systems and resonace decay products. Store trimmed
+  // event in workEvent.
+  sortIncomingProcess(event);
+
+  // Get (kinematical) pT of first emission
+  double pTfirst = 0.;
+
+  // Get weak bosons, for later checks if the emission is a "QCD emission".
+  vector<int> weakBosons;
+  for (int i = 0; i < event.size(); i++) {
+    if ( event[i].id() == 22
+      && event[i].id() == 23
+      && event[i].idAbs() == 24)
+      weakBosons.push_back(i);
+  }
+
+  for (int i =  workEvent.size()-1; i > 0; --i) {
+    if ( workEvent[i].isFinal() && workEvent[i].colType() != 0
+      && (workEvent[i].statusAbs() == 43 || workEvent[i].statusAbs() == 51)) {
+      // Check if any of the EW bosons are ancestors of this parton. This
+      // should never happen for the first non-resonance shower emission.
+      // Check just to be sure.
+      bool QCDemission = true;
+      // Get position of this parton in the actual event (workEvent does
+      // not contain right mother-daughter relations). Stored in daughters.
+      int iPosOld = workEvent[i].daughter1();
+      for (int j = 0; i < int(weakBosons.size()); ++i)
+        if ( event[iPosOld].isAncestor(j)) {
+          QCDemission = false;
+          break;
+        }
+      // Done for a QCD emission.
+      if (QCDemission){
+        pTfirst = workEvent[i].pT();
+        break;
+      }
+    }
+  }
+
+  // Store things that are necessary to perform the shower-kT veto externally.
+  pTfirstSave   = pTfirst;
+  // Done if only inputs for an external vetoing procedure should be stored.
+  if (!performVeto) return false;
+
+  // Check veto.
+  if ( doShowerKtVeto(pTfirst) ) return true;
+
+  // No veto if come this far.
+  return false;
+
+}
+
+//--------------------------------------------------------------------------
+
+inline bool JetMatchingMadgraph::doShowerKtVeto(double pTfirst) {
+
+  // Only check veto in the shower-kT scheme.
+  if ( !doShowerKt ) return false;
+
+  // Reset veto code
+  bool doVeto = false;
+
+  // Find the (kinematical) pT of the softest (light) parton in the hard
+  // process.
+  int nParton = typeIdx[0].size();
+  double pTminME=1e10;
+  for ( int i = 0; i < nParton; ++i)
+    pTminME = min(pTminME,eventProcess[typeIdx[0][i]].pT());
+
+  // Veto if the softest hard process parton is below Qcut.
+  if ( nParton > 0 && pow(pTminME,2) < qCutSq ) doVeto = true;
+
+  // For non-highest multiplicity, veto if the hardest emission is harder
+  // than Qcut.
+  if ( exclusive && pow(pTfirst,2) > qCutSq ) {
+    doVeto = true;
+  // For highest multiplicity sample, veto if the hardest emission is harder
+  // than the hard process parton.
+  } else if ( !exclusive && nParton > 0 && pTfirst > pTminME ) {
+    doVeto = true;
+  }
+
+  // Return veto
+  return doVeto;
+
+}
+
+//--------------------------------------------------------------------------
+
+// Function to set the jet clustering scales (to be used as output)
+
+inline void JetMatchingMadgraph::setDJR( const Event& event) {
+
+ // Clear members.
+ clearDJR();
+ vector<double> result;
+
+  // Initialize SlowJetDJR jet algorithm with event
+  if (!slowJetDJR->setup(event) ) {
+    errorMsg("Warning in JetMatchingMadgraph:setDJR"
+      ": the SlowJet algorithm failed on setup");
+    return;
+  }
+
+  // Cluster in steps to find all hadronic jets
+  while ( slowJetDJR->sizeAll() - slowJetDJR->sizeJet() > 0 ) {
+    // Save the next clustering scale.
+    result.push_back(sqrt(slowJetDJR->dNext()));
+    // Perform step.
+    slowJetDJR->doStep();
+  }
+
+  // Save clustering scales in reserve order.
+  for (int i=int(result.size())-1; i >= 0; --i)
+    DJR.push_back(result[i]);
+
+}
+
+//--------------------------------------------------------------------------
+
+// Function to get the current number of partons in the Born state, as
+// read from LHE.
+
+inline int JetMatchingMadgraph::npNLO(){
+  string npIn = infoPtr->getEventAttribute("npNLO",true);
+  int np = (npIn != "") ? atoi((char*)npIn.c_str()) : -1;
+  if ( np < 0 ) { ; }
+  else return np;
+  return nPartonsNow;
+}
+
+//--------------------------------------------------------------------------
+
+// Step (1): sort the incoming particles
+
+inline void JetMatchingMadgraph::sortIncomingProcess(const Event &event) {
+
+  // Remove resonance decays from original process and keep only final
+  // state. Resonances will have positive status code after this step.
+  omitResonanceDecays(eventProcessOrig, true);
+  clearDJR();
+  clear_nMEpartons();
+
+  // For FxFx, pre-cluster partons in the event into jets.
+  if (doFxFx) {
+
+    // Get final state partons
+    eventProcess.clear();
+    workEventJet.clear();
+    for( int i=0; i < workEvent.size(); ++i) {
+      // Original AG+Py6 algorithm explicitly excludes tops,
+      // leptons and photons.
+      int id = workEvent[i].idAbs();
+      if ((id >= ID_LEPMIN && id <= ID_LEPMAX) || id == ID_TOP
+        || id == ID_PHOTON || id == 23 || id == 24 || id == 25) {
+        eventProcess.append(workEvent[i]);
+      } else {
+        workEventJet.append(workEvent[i]);
+      }
+    }
+
+    // Initialize SlowJetHard jet algorithm with current working event
+    if (!slowJetHard->setup(workEventJet) ) {
+      errorMsg("Warning in JetMatchingMadgraph:sortIncomingProcess"
+        ": the SlowJet algorithm failed on setup");
+      return;
+    }
+
+    // Get matrix element cut scale.
+    double localQcutSq = qCutMESq;
+    // Cluster in steps to find all hadronic jets at the scale qCutME
+    while ( slowJetHard->sizeAll() - slowJetHard->sizeJet() > 0 ) {
+      // Done if next step is above qCut
+      if( slowJetHard->dNext() > localQcutSq ) break;
+      // Done if we're at or below the number of partons in the Born state.
+      if( slowJetHard->sizeAll()-slowJetHard->sizeJet() <= npNLO()) break;
+      slowJetHard->doStep();
+    }
+
+    // Construct a master copy of the event containing only the
+    // hardest nPartonsNow hadronic clusters. While constructing the event,
+    // the parton type (ID_GLUON) and status (98,99) are arbitrary.
+    int nJets = slowJetHard->sizeJet();
+    int nClus = slowJetHard->sizeAll();
+    int nNow = 0;
+    for (int i = nJets; i < nClus; ++i) {
+      vector<int> parts;
+      if (i < nClus-nJets) parts = slowJetHard->clusConstituents(i);
+      else parts = slowJetHard->constituents(nClus-nJets-i);
+      int flavour = ID_GLUON;
+      for(int j=0; j < int(parts.size()); ++j)
+        if (workEventJet[parts[j]].id() == ID_BOT)
+          flavour = ID_BOT;
+      eventProcess.append( flavour, 98,
+        workEventJet[parts.back()].mother1(),
+        workEventJet[parts.back()].mother2(),
+        workEventJet[parts.back()].daughter1(),
+        workEventJet[parts.back()].daughter2(),
+        0, 0, slowJetHard->p(i).px(), slowJetHard->p(i).py(),
+        slowJetHard->p(i).pz(), slowJetHard->p(i).e() );
+      nNow++;
+    }
+
+    // Done. Clean-up
+    workEventJet.clear();
+
+  // For MLM matching, simply take hard process state from workEvent,
+  // without any preclustering.
+  } else {
+    eventProcess = workEvent;
+  }
+
+  // Sort original process final state into light/heavy jets and 'other'.
+  // Criteria:
+  //   1 <= ID <= nQmatch, or ID == 21         --> light jet (typeIdx[0])
+  //   nQMatch < ID                            --> heavy jet (typeIdx[1])
+  //   All else that is colored                --> other     (typeIdx[2])
+  // Note that 'typeIdx' stores indices into 'eventProcess' (after resonance
+  // decays are omitted), while 'typeSet' stores indices into the original
+  // process record, 'eventProcessOrig', but these indices are also valid
+  // in 'event'.
+  for (int i = 0; i < 3; i++) {
+    typeIdx[i].clear();
+    typeSet[i].clear();
+    origTypeIdx[i].clear();
+  }
+  for (int i = 0; i < eventProcess.size(); i++) {
+    // Ignore non-final state and default to 'other'
+    if (!eventProcess[i].isFinal()) continue;
+    int idx = -1;
+    int orig_idx = -1;
+
+    // Light jets: all gluons and quarks with id less than or equal to nQmatch
+    if (eventProcess[i].isGluon()
+      || (eventProcess[i].idAbs() <= nQmatch) ) {
+      orig_idx = 0;
+      // Crucial point: MG puts the scale of a non-QCD particle to eCM. For
+      // such particles, we should keep the default "2"
+      idx = ( eventProcess[i].scale() < 1.999 * sqrt(infoPtr->eA()
+        * infoPtr->eB()) ) ? 0 : 2;
+    }
+
+    // Heavy jets:  all quarks with id greater than nQmatch
+    else if (eventProcess[i].idAbs() > nQmatch
+      && eventProcess[i].idAbs() <= ID_TOP) {
+      idx = 1;
+      orig_idx = 1;
+    // Update to include non-SM colored particles
+    } else if (eventProcess[i].colType() != 0
+      && eventProcess[i].idAbs() > ID_TOP) {
+      idx = 1;
+      orig_idx = 1;
+    }
+    if( idx < 0 ) continue;
+    // Store
+    typeIdx[idx].push_back(i);
+    typeSet[idx].insert(eventProcess[i].daughter1());
+    origTypeIdx[orig_idx].push_back(i);
+  }
+
+  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
+  if (exclusiveMode == 2) {
+
+    // Inclusive if nJet == nJetMax, exclusive otherwise
+    int nParton = origTypeIdx[0].size();
+    exclusive = (nParton == nJetMax) ? false : true;
+
+  // Otherwise, just set as given
+  } else {
+    exclusive = (exclusiveMode == 0) ? false : true;
+  }
+
+  // Extract partons from hardest subsystem + ISR + FSR only into
+  // workEvent. Note no resonance showers or MPIs.
+  subEvent(event);
+
+  // Store things that are necessary to perform the kT-MLM veto externally.
+  int nParton = typeIdx[0].size();
+  processSubsetSave.clear();
+  for ( int i = 0; i < nParton; ++i)
+    processSubsetSave.append( eventProcess[typeIdx[0][i]] );
+
+}
+
+//--------------------------------------------------------------------------
+
+// Step (2a): pick which particles to pass to the jet algorithm
+
+inline void JetMatchingMadgraph::jetAlgorithmInput(const Event &event,
+  int iType) {
+
+  // Take input from 'workEvent' and put output in 'workEventJet'
+  workEventJet = workEvent;
+
+  // Loop over particles and decide what to pass to the jet algorithm
+  for (int i = 0; i < workEventJet.size(); ++i) {
+    if (!workEventJet[i].isFinal()) continue;
+
+    // jetAllow option to disallow certain particle types
+    if (jetAllow == 1) {
+      // Remove all non-QCD partons from veto list
+      if( workEventJet[i].colType() == 0 ) {
+        workEventJet[i].statusNeg();
+        continue;
+      }
+    }
+
+    // Get the index of this particle in original event
+    int idx = workEventJet[i].daughter1();
+
+    // Start with particle idx, and afterwards track mothers
+    while (true) {
+
+      // Light jets
+      if (iType == 0) {
+
+        // Do not include if originates from heavy jet or 'other'
+        if (typeSet[1].find(idx) != typeSet[1].end() ||
+            typeSet[2].find(idx) != typeSet[2].end()) {
+          workEventJet[i].statusNeg();
+          break;
+        }
+
+        // Made it to start of event record so done
+        if (idx == 0) break;
+        // Otherwise next mother and continue
+        idx = event[idx].mother1();
+
+      // Heavy jets
+      } else if (iType == 1) {
+
+        // Only include if originates from heavy jet
+        if (typeSet[1].find(idx) != typeSet[1].end()) break;
+
+        // Made it to start of event record with no heavy jet mother,
+        // so DO NOT include particle
+        if (idx == 0) {
+          workEventJet[i].statusNeg();
+          break;
+        }
+
+        // Otherwise next mother and continue
+        idx = event[idx].mother1();
+
+      // Other jets
+      } else if (iType == 2) {
+
+        // Only include if originates from other jet
+        if (typeSet[2].find(idx) != typeSet[2].end()) break;
+
+        // Made it to start of event record with no heavy jet mother,
+        // so DO NOT include particle
+        if (idx == 0) {
+          workEventJet[i].statusNeg();
+          break;
+        }
+
+        // Otherwise next mother and continue
+        idx = event[idx].mother1();
+
+      } // if (iType)
+    } // while (true)
+  } // for (i)
+}
+
+//--------------------------------------------------------------------------
+
+// Step (2b): run jet algorithm and provide common output
+// This does nothing, because the jet algorithm is run several times
+//  in the matching algorithm.
+
+inline void JetMatchingMadgraph::runJetAlgorithm() {; }
+
+//--------------------------------------------------------------------------
+
+// Step (2c): veto decision (returning true vetoes the event)
+
+inline bool JetMatchingMadgraph::matchPartonsToJets(int iType) {
+
+  // Use different routines for light/heavy/other jets as
+  // different veto conditions and for clarity
+  if (iType == 0) {
+    // Record the jet separations here, also if matchPartonsToJetsLight
+    // returns preemptively.
+    setDJR(workEventJet);
+    set_nMEpartons(origTypeIdx[0].size(), typeIdx[0].size());
+    // Perform jet matching.
+    return (matchPartonsToJetsLight() > 0);
+  } else if (iType == 1) {
+     return (matchPartonsToJetsHeavy() > 0);
+  } else {
+     return (matchPartonsToJetsOther() > 0);
+  }
+
+}
+
+//--------------------------------------------------------------------------
+
+// Step(2c): light jets
+// Return codes are given indicating the reason for a veto.
+// Although not currently used, they are a useful debugging tool:
+//   0 = no veto
+//   1 = veto as number of jets less than number of partons
+//   2 = veto as exclusive mode and number of jets greater than
+//       number of partons
+//   3 = veto as inclusive mode and there would be an extra jet
+//       that is harder than any matched soft jet
+//   4 = veto as there is a parton which does not match a jet
+
+inline int JetMatchingMadgraph::matchPartonsToJetsLight() {
+
+  // Store things that are necessary to perform the kT-MLM veto externally.
+  workEventJetSave  = workEventJet;
+  // Done if only inputs for an external vetoing procedure should be stored.
+  if (!performVeto) return false;
+
+  // Count the number of hard partons
+  int nParton = typeIdx[0].size();
+
+  // Initialize SlowJet with current working event
+  if (!slowJet->setup(workEventJet) ) {
+    errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
+      "Light: the SlowJet algorithm failed on setup");
+    return NONE;
+  }
+  double localQcutSq = qCutSq;
+  double dOld = 0.0;
+  // Cluster in steps to find all hadronic jets at the scale qCut
+  while ( slowJet->sizeAll() - slowJet->sizeJet() > 0 ) {
+    if( slowJet->dNext() > localQcutSq ) break;
+    dOld = slowJet->dNext();
+    slowJet->doStep();
+  }
+  int nJets = slowJet->sizeJet();
+  int nClus = slowJet->sizeAll();
+
+  // Debug printout.
+  if (MATCHINGDEBUG) slowJet->list(true);
+
+  // Count of the number of hadronic jets in SlowJet accounting
+  int nCLjets = nClus - nJets;
+  // Get number of partons. Different for MLM and FxFx schemes.
+  int nRequested = (doFxFx) ? npNLO() : nParton;
+
+  // Veto event if too few hadronic jets
+  if ( nCLjets < nRequested ) return LESS_JETS;
+
+  // In exclusive mode, do not allow more hadronic jets than partons
+  if ( exclusive && !doFxFx ) {
+    if ( nCLjets > nRequested ) return MORE_JETS;
+  } else {
+
+    // For FxFx, in the non-highest multipicity, all jets need to matched to
+    // partons. For nCLjets > nRequested, this is not possible. Hence, we can
+    // veto here already.
+    if ( doFxFx && nRequested < nJetMax && nCLjets > nRequested )
+      return MORE_JETS;
+
+    // Now continue in inclusive mode.
+    // In inclusive mode, there can be more hadronic jets than partons,
+    // provided that all partons are properly matched to hadronic jets.
+    // Start by setting up the jet algorithm.
+    if (!slowJet->setup(workEventJet) ) {
+      errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
+        "Light: the SlowJet algorithm failed on setup");
+      return NONE;
+    }
+
+    // For FxFx, continue clustering as long as the jet separation is above
+    // qCut.
+    if (doFxFx) {
+      while ( slowJet->sizeAll() - slowJet->sizeJet() > 0 ) {
+        if( slowJet->dNext() > localQcutSq ) break;
+        slowJet->doStep();
+      }
+    // For MLM, cluster into hadronic jets until there are the same number as
+    // partons.
+    } else {
+      while ( slowJet->sizeAll() - slowJet->sizeJet() > nParton )
+        slowJet->doStep();
+    }
+
+    // Sort partons in pT.  Update local qCut value.
+    //  Hadronic jets are already sorted in pT.
+    localQcutSq = dOld;
+    if ( clFact >= 0. && nParton > 0 ) {
+       vector<double> partonPt;
+       for (int i = 0; i < nParton; ++i)
+         partonPt.push_back( eventProcess[typeIdx[0][i]].pT2() );
+       sort( partonPt.begin(), partonPt.end());
+       localQcutSq = max( qCutSq, partonPt[0]);
+    }
+    nJets = slowJet->sizeJet();
+    nClus = slowJet->sizeAll();
+  }
+  // Update scale if clustering factor is non-zero
+  if ( clFact != 0. ) localQcutSq *= pow2(clFact);
+
+  Event tempEvent;
+  tempEvent.init( "(tempEvent)", particleDataPtr);
+  int nPass = 0;
+  double pTminEstimate = -1.;
+  // Construct a master copy of the event containing only the
+  // hardest nParton hadronic clusters. While constructing the event,
+  // the parton type (ID_GLUON) and status (98,99) are arbitrary.
+  for (int i = nJets; i < nClus; ++i) {
+    tempEvent.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0, slowJet->p(i).px(),
+      slowJet->p(i).py(), slowJet->p(i).pz(), slowJet->p(i).e() );
+    ++nPass;
+    pTminEstimate = max( pTminEstimate, slowJet->pT(i));
+    if(nPass == nRequested) break;
+  }
+
+  int tempSize = tempEvent.size();
+  // This keeps track of which hadronic jets are matched to parton
+  vector<bool> jetAssigned;
+  jetAssigned.assign( tempSize, false);
+
+  // This keeps track of which partons are matched to which hadronic
+  // jets.
+  vector< vector<bool> > partonMatchesJet;
+  for (int i=0; i < nParton; ++i )
+    partonMatchesJet.push_back( vector<bool>(tempEvent.size(),false) );
+
+  // Begin matching.
+  // Do jet matching for FxFx.
+  // Make sure that the nPartonsNow hardest hadronic jets are matched to any
+  // of the nPartonsNow (+1) partons. This matching is done by attaching a jet
+  // from the list of unmatched hadronic jets, and appending a jet from the
+  // list of partonic jets, one at a time. The partonic jet will be clustered
+  // with the hadronic jet or the beam if the distance measure is below the
+  // cut. The hadronic jet is matched once this happens. Otherwise, another
+  // partonic jet is tried. When a hadronic jet is matched to a partonic jet,
+  // it is removed from the list of unmatched hadronic jets. This process
+  // continues until the nPartonsNow hardest hadronic jets are matched to
+  // partonic jets, or it is not possible to make a match for a hadronic jet.
+  int iNow = 0;
+  int nMatched = 0;
+  while ( doFxFx && iNow < tempSize ) {
+
+    // Check if this shower jet matches any partonic jet.
+    Event tempEventJet;
+    tempEventJet.init("(tempEventJet)", particleDataPtr);
+    for (int i=0; i < nParton; ++i ) {
+
+      //// Only assign a parton once.
+      //for (int j=0; j < tempSize; ++j )
+      //  if ( partonMatchesJet[i][j]) continue;
+
+      // Attach a single hadronic jet.
+      tempEventJet.clear();
+      tempEventJet.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0,
+        tempEvent[iNow].px(), tempEvent[iNow].py(),
+        tempEvent[iNow].pz(), tempEvent[iNow].e() );
+      // Attach the current parton.
+      Vec4 pIn = eventProcess[typeIdx[0][i]].p();
+      tempEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0,
+        pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
+
+      // Setup jet algorithm.
+      if ( !slowJet->setup(tempEventJet) ) {
+        errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
+          "Light: the SlowJet algorithm failed on setup");
+        return NONE;
+      }
+
+      // These are the conditions for the hadronic jet to match the parton
+      //  at the local qCut scale
+      if ( slowJet->iNext() == tempEventJet.size() - 1
+        && slowJet->jNext() > -1 && slowJet->dNext() < localQcutSq ) {
+        jetAssigned[iNow] = true;
+        partonMatchesJet[i][iNow] = true;
+      }
+
+    } // End loop over hard partons.
+
+    // Veto if the jet could not be assigned to any parton.
+    if ( jetAssigned[iNow] ) nMatched++;
+
+    // Continue;
+    ++iNow;
+  }
+
+  // Jet matching veto for FxFx
+  if (doFxFx) {
+    if ( nRequested <  nJetMax && nMatched != nRequested )
+      return UNMATCHED_PARTON;
+    if ( nRequested == nJetMax && nMatched <  nRequested )
+      return UNMATCHED_PARTON;
+  }
+
+  // Do jet matching for MLM.
+  // Take the list of unmatched hadronic jets and append a parton, one at
+  // a time. The parton will be clustered with the "closest" hadronic jet
+  // or the beam if the distance measure is below the cut. When a hadronic
+  // jet is matched to a parton, it is removed from the list of unmatched
+  // hadronic jets. This process continues until all hadronic jets are
+  // matched to partons or it is not possible to make a match.
+  iNow = 0;
+  while (!doFxFx && iNow < nParton ) {
+    Event tempEventJet;
+    tempEventJet.init("(tempEventJet)", particleDataPtr);
+    for (int i = 0; i < tempSize; ++i) {
+      if (jetAssigned[i]) continue;
+      Vec4 pIn = tempEvent[i].p();
+      // Append unmatched hadronic jets
+      tempEventJet.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0,
+        pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
+    }
+
+    Vec4 pIn = eventProcess[typeIdx[0][iNow]].p();
+    // Append the current parton
+    tempEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0,
+      pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
+    if ( !slowJet->setup(tempEventJet) ) {
+      errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
+        "Light: the SlowJet algorithm failed on setup");
+      return NONE;
+    }
+    // These are the conditions for the hadronic jet to match the parton
+    //  at the local qCut scale
+    if ( slowJet->iNext() == tempEventJet.size() - 1
+      && slowJet->jNext() > -1 && slowJet->dNext() < localQcutSq ) {
+      int iKnt = -1;
+      for (int i = 0; i != tempSize; ++i) {
+        if (jetAssigned[i]) continue;
+        ++iKnt;
+        // Identify the hadronic jet that matches the parton
+        if (iKnt == slowJet->jNext() ) jetAssigned[i] = true;
+      }
+    } else {
+      return UNMATCHED_PARTON;
+    }
+    ++iNow;
+  }
+
+  // Minimal eT/pT (CellJet/SlowJet) of matched light jets.
+  // Needed later for heavy jet vetos in inclusive mode.
+  // This information is not used currently.
+  if (nParton > 0 && pTminEstimate > 0) eTpTlightMin = pTminEstimate;
+  else eTpTlightMin = -1.;
+
+  // Record the jet separations.
+  setDJR(workEventJet);
+
+  // No veto
+  return NONE;
+}
+
+//--------------------------------------------------------------------------
+
+// Step(2c): heavy jets
+// Return codes are given indicating the reason for a veto.
+// Although not currently used, they are a useful debugging tool:
+//   0 = no veto as there are no extra jets present
+//   1 = veto as in exclusive mode and extra jets present
+//   2 = veto as in inclusive mode and extra jets were harder
+//       than any matched light jet
+
+inline int JetMatchingMadgraph::matchPartonsToJetsHeavy() {
+
+  // Currently, heavy jets are unmatched
+  // If there are no extra jets, then accept
+  // jetMomenta is NEVER used by MadGraph and is always empty.
+  //  This check does nothing.
+  //  Rather, if there is any heavy flavor that is harder than
+  //  what is present at the LHE level, then the event should
+  //  be vetoed.
+
+  // if (jetMomenta.empty()) return NONE;
+  // Count the number of hard partons
+  int nParton = typeIdx[1].size();
+
+  Event tempEventJet(workEventJet);
+
+  double scaleF(1.0);
+  // Rescale the heavy partons that are from the hard process to
+  //  have pT=collider energy.   Soft/collinear gluons will cluster
+  //  onto them, leaving a remnant of hard emissions.
+  for( int i=0; i<nParton; ++i) {
+    scaleF = eventProcessOrig[0].e()/workEventJet[typeIdx[1][i]].pT();
+    tempEventJet[typeIdx[1][i]].rescale5(scaleF);
+  }
+
+  if (!hjSlowJet->setup(tempEventJet) ) {
+    errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
+             "Heavy: the SlowJet algorithm failed on setup");
+    return NONE;
+  }
+
+
+  while ( hjSlowJet->sizeAll() - hjSlowJet->sizeJet() > 0 ) {
+    if( hjSlowJet->dNext() > qCutSq ) break;
+    hjSlowJet->doStep();
+  }
+
+  int nCLjets(0);
+  // Count the number of clusters with pT>qCut.  This includes the
+  //  original hard partons plus any hard emissions.
+  for(int idx=0 ; idx< hjSlowJet->sizeAll(); ++idx) {
+    if( hjSlowJet->pT(idx) > sqrt(qCutSq) ) nCLjets++;
+  }
+
+  // Debug printout.
+  if (MATCHINGDEBUG) hjSlowJet->list(true);
+
+  // Count of the number of hadronic jets in SlowJet accounting
+  //  int nCLjets = nClus - nJets;
+  // Get number of partons. Different for MLM and FxFx schemes.
+  int nRequested = nParton;
+
+  // Veto event if too few hadronic jets
+  if ( nCLjets < nRequested ) {
+    if (MATCHINGDEBUG) cout << "veto : hvy  LESS_JETS " << endl;
+    if (MATCHINGDEBUG) cout << "nCLjets = " << nCLjets << "; nRequest = "
+      << nRequested << endl;
+    return LESS_JETS;
+  }
+
+  // In exclusive mode, do not allow more hadronic jets than partons
+  if ( exclusive ) {
+    if ( nCLjets > nRequested ) {
+      if (MATCHINGDEBUG) cout << "veto : excl hvy  MORE_JETS " << endl;
+      return MORE_JETS;
+    }
+  }
+
+  // No extra jets were present so no veto
+  return NONE;
+}
+
+//--------------------------------------------------------------------------
+
+// Step(2c): other jets
+// Return codes are given indicating the reason for a veto.
+// Although not currently used, they are a useful debugging tool:
+//   0 = no veto as there are no extra jets present
+//   1 = veto as in exclusive mode and extra jets present
+//   2 = veto as in inclusive mode and extra jets were harder
+//       than any matched light jet
+
+inline int JetMatchingMadgraph::matchPartonsToJetsOther() {
+
+  // Currently, heavy jets are unmatched
+  // If there are no extra jets, then accept
+  // jetMomenta is NEVER used by MadGraph and is always empty.
+  //  This check does nothing.
+  //  Rather, if there is any heavy flavor that is harder than
+  //  what is present at the LHE level, then the event should
+  //  be vetoed.
+
+  // if (jetMomenta.empty()) return NONE;
+  // Count the number of hard partons
+  int nParton = typeIdx[2].size();
+
+  Event tempEventJet(workEventJet);
+
+  double scaleF(1.0);
+  // Rescale the heavy partons that are from the hard process to
+  //  have pT=collider energy.   Soft/collinear gluons will cluster
+  //  onto them, leaving a remnant of hard emissions.
+  for( int i=0; i<nParton; ++i) {
+    scaleF = eventProcessOrig[0].e()/workEventJet[typeIdx[2][i]].pT();
+    tempEventJet[typeIdx[2][i]].rescale5(scaleF);
+  }
+
+  if (!hjSlowJet->setup(tempEventJet) ) {
+    errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
+             "Heavy: the SlowJet algorithm failed on setup");
+    return NONE;
+  }
+
+
+  while ( hjSlowJet->sizeAll() - hjSlowJet->sizeJet() > 0 ) {
+    if( hjSlowJet->dNext() > qCutSq ) break;
+    hjSlowJet->doStep();
+  }
+
+  int nCLjets(0);
+  // Count the number of clusters with pT>qCut.  This includes the
+  //  original hard partons plus any hard emissions.
+  for(int idx=0 ; idx< hjSlowJet->sizeAll(); ++idx) {
+    if( hjSlowJet->pT(idx) > sqrt(qCutSq) ) nCLjets++;
+  }
+
+  // Debug printout.
+  if (MATCHINGDEBUG) hjSlowJet->list(true);
+
+  // Count of the number of hadronic jets in SlowJet accounting
+  //  int nCLjets = nClus - nJets;
+  // Get number of partons. Different for MLM and FxFx schemes.
+  int nRequested = nParton;
+
+  // Veto event if too few hadronic jets
+  if ( nCLjets < nRequested ) {
+    if (MATCHINGDEBUG) cout << "veto : other LESS_JETS " << endl;
+    if (MATCHINGDEBUG) cout << "nCLjets = " << nCLjets << "; nRequest = "
+      << nRequested << endl;
+    return LESS_JETS;
+  }
+
+  // In exclusive mode, do not allow more hadronic jets than partons
+  if ( exclusive ) {
+    if ( nCLjets > nRequested ) {
+      if (MATCHINGDEBUG) cout << "veto : excl other MORE_JETS" << endl;
+      return MORE_JETS;
+    }
+  }
+
+  // No extra jets were present so no veto
+  return NONE;
+}
+
+
+} // end namespace Pythia8
diff -rupN pythia8306_original/src/ProcessLevel.cc pythia8306_patched/src/ProcessLevel.cc
--- pythia8306_original/src/ProcessLevel.cc	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/src/ProcessLevel.cc	2023-06-27 02:09:11.960196135 +0200
@@ -7,6 +7,21 @@
 
 #include "Pythia8/ProcessLevel.h"
 
+// NOTE: Gambit hack to limit infinite loops using threadsafe timers.
+#ifndef BOOST_CHRONO_HEADER_ONLY
+#define BOOST_CHRONO_HEADER_ONLY
+#ifndef BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#define BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#ifndef BOOST_SYSTEM_NO_DEPRECATED
+#define BOOST_SYSTEM_NO_DEPRECATED
+#include <boost/chrono.hpp>
+typedef boost::chrono::milliseconds ms;
+typedef boost::chrono::thread_clock thread_cl;
+typedef boost::chrono::thread_clock::time_point thread_tp;
+#endif // BOOST_SYSTEM_NO_DEPRECATED
+#endif // BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#endif // BOOST_CHRONO_HEADER_ONLY
+
 namespace Pythia8 {
 
 //==========================================================================
@@ -192,10 +207,30 @@ bool ProcessLevel::init( bool doLHA, SLH
       ++numberOn;
 
   // Sum maxima for Monte Carlo choice.
+  // NOTE: Gambit hack: Catch nans and infinities while summing up sigmas.
   sigmaMaxSum = 0.;
-  for (int i = 0; i < int(containerPtrs.size()); ++i)
-    sigmaMaxSum += containerPtrs[i]->sigmaMax();
-
+  bool valid = true;
+  for (int i = 0; i < int(containerPtrs.size()); ++i) {
+    if(std::isfinite(containerPtrs[i]->sigmaMax()))
+      sigmaMaxSum += containerPtrs[i]->sigmaMax();
+    else {
+      std::cerr<<"\n\n\n ERROR: in Pythia8::ProcessLevel::init:\n";
+      std::cerr<<"   Non-finite xsec: "<<containerPtrs[i]->sigmaMax()<<"\n";
+      std::cerr<<"   Process code: "<<containerPtrs[i]->code();
+      std::cerr<<",  Process: "<<containerPtrs[i]->name()<<"\n";
+      std::cerr<<"This model is invalid.\n\n\n";
+      delete containerPtrs[i];
+      containerPtrs.erase(containerPtrs.begin() + i);
+      i--;
+      valid = false;
+    }
+  }
+  if (!valid) {
+    infoPtr->errorMsg("Error in ProcessLevel::init: Non-finite xsecs");
+    return false;
+  }
+  
+  
   // Option to pick a second hard interaction: repeat as above.
   int number2On = 0;
   if (doSecondHard) {
@@ -295,12 +330,14 @@ bool ProcessLevel::init( bool doLHA, SLH
          <<"-------------*" << endl;
   }
 
+  /* NOTE: Gambit hack: ColliderBit has its own xsec veto... remove this:
   // If sum of maxima vanishes then refuse to do anything.
   if ( numberOn == 0  || sigmaMaxSum <= 0.) {
     infoPtr->errorMsg("Error in ProcessLevel::init: "
       "all processes have vanishing cross sections");
     return false;
   }
+  *** Gambit hack end */
   if ( doSecondHard && (number2On == 0  || sigma2MaxSum <= 0.) ) {
     infoPtr->errorMsg("Error in ProcessLevel::init: "
       "all second hard processes have vanishing cross sections");
@@ -617,9 +654,16 @@ bool ProcessLevel::nextOne( Event& proce
     if (!physical) process.clear();
     physical = true;
 
+    // NOTE: Gambit hack to limit infinite loops using threadsafe timers.
+    // TODO: configurable msTimeLimit...
     // Loop over tries until trial event succeeds.
-    for ( ; ; ) {
-
+    double msTimer=0.;
+    double msTimeLimit = 1000.;
+    ms msDelta;
+    for (thread_tp start = thread_cl::now(); msTimer < msTimeLimit;
+         msDelta = boost::chrono::duration_cast<ms>(thread_cl::now() - start),
+         msTimer = msDelta.count())
+    {
       // Pick one of the subprocesses.
       double sigmaMaxNow = sigmaMaxSum * rndmPtr->flat();
       int iMax = containerPtrs.size() - 1;
@@ -633,6 +677,11 @@ bool ProcessLevel::nextOne( Event& proce
       // Check for end-of-file condition for Les Houches events.
       if (infoPtr->atEndOfFile()) return false;
     }
+    if (msTimer >= msTimeLimit) {
+      std::cerr<<"\n\n\n WARNING: in Pythia8::ProcessLevel::next:\n";
+      std::cerr<<"   Trial event stuck. Aborting event generation\n\n\n";
+      return false;
+    }
 
     // Update sum of maxima if current maximum violated.
     if (containerPtrs[iContainer]->newSigmaMax()) {
diff -rupN pythia8306_original/src/Pythia.cc pythia8306_patched/src/Pythia.cc
--- pythia8306_original/src/Pythia.cc	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/src/Pythia.cc	2023-06-27 02:10:44.628197267 +0200
@@ -843,7 +843,8 @@ bool Pythia::init() {
 
   // Initialize SLHA interface (including SLHA/BSM couplings).
   bool useSLHAcouplings = false;
-  slhaInterface = SLHAinterface();
+  // GAMBIT patch
+  // slhaInterface = SLHAinterface();
   slhaInterface.setPtr( &infoPrivate);
   slhaInterface.init( useSLHAcouplings, particleDataBuffer );
 
diff -rupN pythia8306_original/src/ResonanceDecays.cc pythia8306_patched/src/ResonanceDecays.cc
--- pythia8306_original/src/ResonanceDecays.cc	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/src/ResonanceDecays.cc	2023-06-27 02:09:11.956196135 +0200
@@ -192,12 +192,17 @@ bool ResonanceDecays::pickMasses() {
     mSumMin     += mMinBW[i];
   }
 
-  // If sum of minimal masses above mother mass then give up.
-  if (mSumMin + MSAFETY > mMother) return false;
-
+  
+  // GAMBIT modification to allow decays at small mass splittings:
+  // Switched order of the two next if-statements and changed
+  // 0.5*MSAFETY to 0.01*MSAFETY.
+   
   // If sum of masses below and no Breit-Wigners then done.
-  if (mSum + 0.5 * MSAFETY < mMother && nBW == 0) return true;
+  if (mSum + 0.01 * MSAFETY < mMother && nBW == 0) return true;
 
+  // If sum of minimal masses above mother mass then give up.
+  if (mSumMin + MSAFETY > mMother) return false;
+  
   // Else if below then retry Breit-Wigners, with simple treshold.
   if (mSum + MSAFETY < mMother) {
     double wtMax = 2. * sqrtpos(1. - mSum*mSum / m2Mother);
diff -rupN pythia8306_original/src/SusyLesHouches.cc pythia8306_patched/src/SusyLesHouches.cc
--- pythia8306_original/src/SusyLesHouches.cc	2021-06-29 16:10:32.000000000 +0200
+++ pythia8306_patched/src/SusyLesHouches.cc	2023-06-27 02:09:11.956196135 +0200
@@ -20,23 +20,34 @@ namespace Pythia8 {
 int SusyLesHouches::readFile(string slhaFileIn, int verboseIn,
   bool useDecayIn) {
 
-  slhaFile = slhaFileIn;
-  // Check that input file is OK.
-  const char* cstring = slhaFile.c_str();
-  igzstream file(cstring);
-
-  // Exit if input file not found. Else print file name.
-  if (!file.good()) {
-    message(2,"readFile",slhaFile+" not found",0);
-    slhaRead = false;
-    return -1;
-  }
-  if (verboseSav >= 3) {
-    message(0,"readFile","parsing "+slhaFile,0);
-    filePrinted = true;
+  // NOTE: Gambit hack for slhaea support:
+  // If the slhaeaCollPtr is set, get the SLHA content as a stringstream
+  // from that pointer and pass this to Pythia's readFile function.
+  if (slhaeaCollPtr) // GAMBIT hack
+  {
+    std::istringstream slhaea_content(slhaeaCollPtr->str());
+    return readFile( slhaea_content, verboseIn, useDecayIn );
+  }
+  else  // Pythia original
+  {
+    slhaFile = slhaFileIn;
+    // Check that input file is OK.
+    const char* cstring = slhaFile.c_str();
+    igzstream file(cstring);
+  
+    // Exit if input file not found. Else print file name.
+    if (!file.good()) {
+      message(2,"readFile",slhaFile+" not found",0);
+      slhaRead=false;
+      return -1;
+    }
+    if (verboseSav >= 3) {
+      message(0,"readFile","parsing "+slhaFile,0);
+      filePrinted = true;
+    }
+    return readFile( file, verboseIn, useDecayIn );
   }
-
-  return readFile( file, verboseIn, useDecayIn );
+  
 }
 
 int SusyLesHouches::readFile(istream& is, int verboseIn,
@@ -679,6 +690,13 @@ void SusyLesHouches::listFooter() {
 
 void SusyLesHouches::listSpectrum(int ifail) {
 
+  // NOTE: Gambit hack for debugging
+  // Print a debugging message
+  if (ifail == 999) {
+    std::cout<<"\n\n!! SusyLesHouches within libpythia has been touched. !!\n\n";
+    return;
+  }
+  
   // Exit if output switched off
   if (verboseSav <= 0) return;
 
@@ -1506,6 +1524,8 @@ int SusyLesHouches::checkSpectrum() {
     }
   }
 
+  // GAMBIT NMSSM hack
+  /*
   // CPV
   if (modsel(5) != 0) {
     if (!cvhmix.exists()) {
@@ -1513,6 +1533,7 @@ int SusyLesHouches::checkSpectrum() {
       ifail=-1;
     }
   }
+   */
 
   // FLV (regardless of whether RPV or not)
   if (modsel(6) != 0) {
@@ -1648,7 +1669,7 @@ int SusyLesHouches::checkSpectrum() {
       }
     }
   }
-
+  
   //VMIX, UMIX
   if (vmix.exists() && umix.exists()) {
     // First check for non-standard "madgraph" convention
